{
  "hash": "ac758a945d6168ebf0530564367e3cfa",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python is cool ❄\"\ndescription: \"Less-known Python features\"\nauthor:\n  - name: \"Tuan Le Khac\"\n    url: https://lktuan.github.io/\ndate: 05-21-2024\ncategories: [Python, Lambda] # self-defined categories\nimage: python.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n\nformat: \n  html: \n    code-fold: false\n    code-summary: \"Show the code\"\n    code-line-numbers: true\ncss: html/styles.scss\nfig-cap-location: bottom\neditor: visual\n---\n\n# 1. Motivation\n\n------------------------------------------------------------------------\n\nĐây là một bài thực hành theo một [post](https://github.com/chiphuyen/python-is-cool/tree/master) bởi chị [Chip Huyen](https://huyenchip.com/) về một số features đặc biệt của Python. Là một DA không sử dụng Python quá nhiều, chỉ một số feature dưới đây là mình đã từng *nghe* qua. Hi vọng bài thực hành sẽ giúp mình hứng thú với Python hơn!\n\n::: {layout-ncol=1}\n![Dong Nai Cultural Nature Reserve, a python lying along the stream waiting for the prey. Photo credit to [PhucNguyenPhotos](https://www.instagram.com/vietnamphotos_herping/)](python.jpg){width=100%}\n:::\n\n\n# 2. Lambda, map, filter, & reduce\n\n------------------------------------------------------------------------\n\nLambda cho phép người dùng định nghĩa in-line functions. Việc sử dụng `lambda()` rất thuận tiện khi gọi lại (callback \\~ một function được thực thi sau khi một function khác được thực thi; một cách lưu trữ function) hoặc khi đầu ra của một function là đối số cho một function khác.\n\nHai hàm `square_fn` và `square_ld` dưới đây là một:\n\n::: {#e766fa15 .cell execution_count=1}\n``` {.python .cell-code}\ndef square_fn(x):\n    return x * x\n\nsquare_ld = lambda x : x * x\n\nfor i in range(10):\n    assert square_fn(i) == square_ld(i)\n```\n:::\n\n\n`lambda` rất hữu ích khi sử dụng cùng với các function khác như `map`, `filter`, và `reduce` (mình rất hay sử dụng pattern này trên Excel 😂). `map(fn, interable)` sẽ apply hàm `fn` cho tất cả các phần tử trong `iterable` (như list, set, dict, tuple, string), trả về map object.\n\n::: {#748de3e3 .cell execution_count=2}\n``` {.python .cell-code}\nnums = [1/3, 2/7, 1001/37500, 40/27]\nnums_squared = [num * num for num in nums]\nprint(nums_squared)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.1111111111111111, 0.08163265306122448, 0.0007125340444444445, 2.194787379972565]\n```\n:::\n:::\n\n\nDùng `map` và một hàm callback, cho ra kết quả tương đương:\n\n::: {#df4886fd .cell execution_count=3}\n``` {.python .cell-code}\nnums_squared_1 = map(square_fn, nums)\nnums_squared_2 = map(lambda x: x*x, nums)\nprint(list(nums_squared_1)) # list to list the elements of map object\nprint(list(nums_squared_2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.1111111111111111, 0.08163265306122448, 0.0007125340444444445, 2.194787379972565]\n[0.1111111111111111, 0.08163265306122448, 0.0007125340444444445, 2.194787379972565]\n```\n:::\n:::\n\n\nCó thể dùng `map` với nhiều hơn 1 iterable. Ví dụ muốn tính MSE cho một hồi quy tuyến tính đơn giản `f(x) = ax + b` với ground tru `labels`, hai phương pháp sau tương đương:\n\n::: {#05b0305f .cell execution_count=4}\n``` {.python .cell-code}\na, b = 3, -0.5\nxs = [2, 3, 4, 5]\nlabels = [6.4, 8.9, 10.9, 15.3]\n\n# Phương pháp 1, loop\nerrors = []\nfor i,x in enumerate(xs):\n    errors.append( (a * x + b - labels[i])**2 )\nresult_1 = sum(errors)**(1/2) / len(xs)\n\n# Phương pháp 2, map\ndiff = map(lambda x, y: (a * x + b - y) ** 2, xs, labels) \nresult_2 = sum(diff)**.5 / len(xs)\n\nprint(result_1, result_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.35089172119045514 0.35089172119045514\n```\n:::\n:::\n\n\n`filter(fn, iterable)` giống như `map`, tuy nhiên `fn` là một hàm trả về giá trị boolean true/false, và `filter` sẽ trả về các phần tử của `iterable` khi `fn` trả về true.\n\n::: {#05c0aabd .cell execution_count=5}\n``` {.python .cell-code}\nbad_preds = filter(lambda x: x > 0.5, errors)\n\nprint(list(bad_preds))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.8100000000000006, 0.6400000000000011]\n```\n:::\n:::\n\n\n`reduce(fn, iterable, initializer)` được dùng khi ta muốn áp dụng một toán lên tất cả thành phần trong danh sách. Ví dụ muốn tính kết quả nhân của toàn bộ phần tử:\n\n::: {#e93ccb12 .cell execution_count=6}\n``` {.python .cell-code}\nproduct = 1\nfor num in nums:\n    product *= num\nprint(product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.0037662551440329215\n```\n:::\n:::\n\n\nSử dụng `reduce`:\n\n::: {#6a9343b3 .cell execution_count=7}\n``` {.python .cell-code}\nfrom functools import reduce\n\nproduct = reduce(lambda x, y: x * y, nums)\nprint(product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.0037662551440329215\n```\n:::\n:::\n\n\n### Hiệu suất hàm Lambda\n\nLambda được thiết kế để sử dụng một lần. Mỗi lần được gọi, hàm `lambda x: dosomething(x)` đều được tạo lại, và do đó ảnh hưởng tới hiệu suất.\n\nKhi hàm lambda được định nghĩa trước `fn = lambda x: dosomething(x)`, hiệu suất của nó vẫn chậm hơn `def`, tuy nhiên không [đáng kể](https://stackoverflow.com/questions/26540885/lambda-is-slower-than-function-call-in-python-why).\n\n🚀Nguyên văn chị Chip:\n\n> Even though I find lambdas cool, I personally recommend using named functions when you can for the sake of clarity.\n\n# 3. List manipulation\n\n------------------------------------------------------------------------\n\n## 3.1. Unpacking\n\nChúng ta có thể \"giải nén\" một list như thế này:\n\n::: {#3a8e07f3 .cell execution_count=8}\n``` {.python .cell-code}\nelems = [1,2,3,4]\na,b,c,d = elems\n\nprint(a,b,c,d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2 3 4\n```\n:::\n:::\n\n\nCũng có thể làm như thế này:\n\n::: {#b29723f4 .cell execution_count=9}\n``` {.python .cell-code}\na, *new_elems, d = elems # remember the char * for extended unpacking\n\nprint(a)\nprint(new_elems)\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n[2, 3]\n2\n```\n:::\n:::\n\n\n## 3.2. Slicing\n\nChúng ta có thể reverse/đảo ngược một list với `[::-1]`\n\n::: {#5b66950c .cell execution_count=10}\n``` {.python .cell-code}\nelem = list(range(10))\nprint(elem)\n\n\nprint(elem[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n```\n:::\n:::\n\n\nCú pháp `[x:y:z]` có nghĩa là lấy ***mỗi*** phần tử thứ `z` từ index `x` tới index `y`. Khi `z` âm, tương đương với việc lấy theo thứ tự ngược lại. `x` để trống chỉ việc lấy từ phần tử đầu tiên, `y` để rỗng chỉ việc lấy tới phần tử cuối cùng.\n\n::: {#8450b96f .cell execution_count=11}\n``` {.python .cell-code}\nevens = elem[::2]\nprint(evens)\n\nreversed_evens = elem[2::-2]\nprint(reversed_evens)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 2, 4, 6, 8]\n[2, 0]\n```\n:::\n:::\n\n\nCũng có thể dùng slicing để xóa các phần tử như thế này:\n\n::: {#6304b14e .cell execution_count=12}\n``` {.python .cell-code}\ndel elems[::2]\nprint(elems)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4]\n```\n:::\n:::\n\n\n## 3.3. Insertion\n\nChúng ta có thể thay đổi giá trị một phần tử trong một list như sau:\n\n::: {#09e7a085 .cell execution_count=13}\n``` {.python .cell-code}\nelems = list(range(10))\n\nelems[1] = 100\nprint(elems)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 100, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\nCũng có thể thay thế một giá trị bằng nhiều giá trị:\n\n::: {#54dadd82 .cell execution_count=14}\n``` {.python .cell-code}\nelems = list(range(10))\nelems[1:2] = [20, 30, 40]\nprint(elems)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 20, 30, 40, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\nNếu chúng ta muốn thêm 3 giá trị `0.3, 0.4, 0.5` vào giữa phần tử thứ 0 và 1 của list này, thì:\n\n::: {#8fcbcdc9 .cell execution_count=15}\n``` {.python .cell-code}\nelems = list(range(10))\nelems[1:1] = [.3, .4, .5]\nprint(elems)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 0.3, 0.4, 0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\n## 3.4. Flattening\n\nChúng ta có thể flatten một list sử dung `sum(0)`:\n\n::: {#b917142a .cell execution_count=16}\n``` {.python .cell-code}\nlist_of_lists = [[1], [2, 3], [4, 5, 6]]\nsum(list_of_lists, [])\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n[1, 2, 3, 4, 5, 6]\n```\n:::\n:::\n\n\nCũng có thể sử dụng recursive lambda (another beauty of lambda)\n\n::: {#49da237e .cell execution_count=17}\n``` {.python .cell-code}\nnested_lists = [[1, 2], [[3, 4], [5, 6], [[7, 8], [9, 10], [[11, [12, 13]]]]]]\nflatten = lambda x: [y for i in x for y in flatten(i)] if type(x) is list else [x]\n\nprint(flatten(nested_lists))\n\n# This line of code is from\n# https://github.com/sahands/python-by-example/blob/master/python-by-example.rst#flattening-lists\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n```\n:::\n:::\n\n\n## 3.5. List vs Generator\n\n🚀Generator là cái gì vậy? Trích [bài viết](https://manhhomienbienthuy.github.io/2016/01/05/python-iterator-generator.html):\n\n> Từ generator được sử dụng cho cả hàm (hàm generator là hàm đã nói ở trên) và kết quả mà hàm đó sinh ra (đối tượng được hàm generator sinh ra cũng được gọi là generator). Vì vậy đôi khi việc này gây khó hiểu một chút. Hãy xem ví dụ về việc tạo n-grams từ một danh sách tokens dưới đây để hiểu sự khác biệt giữa list và generator:\n\n::: {#ac58a93b .cell execution_count=18}\n``` {.python .cell-code}\ntokens = ['i', 'want', 'to', 'go', 'to', 'school']\n\ndef ngrams(tokens, n):\n    length = len(tokens)\n    grams = []\n    for i in range(length - n + 1):\n        grams.append(tokens[i:i+n])\n    return grams\n\nprint(ngrams(tokens, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[['i', 'want', 'to'], ['want', 'to', 'go'], ['to', 'go', 'to'], ['go', 'to', 'school']]\n```\n:::\n:::\n\n\nTrong ví dụ này, chúng ta phải lưu toàn bộ n-grams một lúc. Nếu có `m` tokens, memory requirement là `O(nm)` - sẽ là vấn đề nếu `m` lớn. Thay vào đó, chúng ta có thể sử dụng generator để tạo n-grams tiếp theo khi được yêu cầu. Đây gọi là lazy evaluation. Chúng ta có thể tạo một hàm `ngrams` trả về một generator sử dụng keyword `yield`, lúc này memory requirement là `O(n+m)`.\n\n::: {#c4eeddbd .cell execution_count=19}\n``` {.python .cell-code}\ndef ngrams(tokens, n):\n    length = len(tokens)\n    for i in range(length - n + 1):\n        yield tokens[i:i+n]\n\nngrams_generator = ngrams(tokens, 3)\nprint(ngrams_generator)\n\nfor ngram in ngrams_generator:\n    print(ngram)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<generator object ngrams at 0x000001CF6CDBD210>\n['i', 'want', 'to']\n['want', 'to', 'go']\n['to', 'go', 'to']\n['go', 'to', 'school']\n```\n:::\n:::\n\n\nMột cách khác để tạo n-grams là slice để lấy các sub-list `[0, 1, 2, ...,-n]`, `[1, 2, 3, ...,-n+1]`, `[2, 3, 4, ...,-n+2]`,... `[n-1, n, ...,-1]`, sau đó `zip` chúng lại:\n\n::: {#fa562b03 .cell execution_count=20}\n``` {.python .cell-code}\ndef ngrams(tokens, n):\n    length = len(tokens)\n    slices = (tokens[i:length-n+i+1] for i in range(n))\n    return zip(*slices)\n\nngrams_generator = ngrams(tokens, 3)\nprint(ngrams_generator)\n\n\nfor ngram in ngrams_generator:\n    print(ngram)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<zip object at 0x000001CF7DFDFFC0>\n('i', 'want', 'to')\n('want', 'to', 'go')\n('to', 'go', 'to')\n('go', 'to', 'school')\n```\n:::\n:::\n\n\nLưu ý chúng ta sử dụng `(tokens[...] for i in range(n))`, chứ không phải `[tokens[...] for i in range(n)]`. `[]` trả về một list, `()` trả về generator. # 4. Classes & magic methods\n\n------------------------------------------------------------------------\n\nTrong Python, magic methods được prefixed và suffixed bởi double underscore `__` (aka dunder). Magic method được biết đến rộng rãi nhất là `__init__`.\n\n::: {#155f3d4d .cell execution_count=21}\n``` {.python .cell-code}\nclass Node:\n    \"\"\" A struct to denote the node of a binary tree.\n    It contains a value and pointers to left and right children.\n    \"\"\"\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n```\n:::\n\n\nIn ra object, tuy nhiên nhìn không tường minh lắm!\n\n::: {#fb664f0b .cell execution_count=22}\n``` {.python .cell-code}\nroot = Node(5)\nprint(root) # <__main__.Node object at 0x1069c4518>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<__main__.Node object at 0x000001CF7C26C550>\n```\n:::\n:::\n\n\nChúng ta mong muốn khi in ra một Node, giá trị của nó cũng như giá trị của các Node con (nếu có) cũng sẽ được in ra. Chúng ta dùng `__repr__`:\n\n::: {#b7dadb6e .cell execution_count=23}\n``` {.python .cell-code}\nclass Node:\n    \"\"\" A struct to denote the node of a binary tree.\n    It contains a value and pointers to left and right children.\n    \"\"\"\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        strings = [f'value: {self.value}']\n        strings.append(f'left: {self.left.value}' if self.left else 'left: None')\n        strings.append(f'right: {self.right.value}' if self.right else 'right: None')\n        return ', '.join(strings)\n\nleft = Node(4)\nroot = Node(5, left)\nprint(root) # value: 5, left: 4, right: None\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nvalue: 5, left: 4, right: None\n```\n:::\n:::\n\n\nChúng ta cũng muốn hai Node có thể được so sánh được với nhau, vì thế tạo ra các magic method để implement các operator: `==` với `__eq__`, `>` với `__lt__`, '\\>=' với `__ge__`:\n\n::: {#0d08bb90 .cell execution_count=24}\n``` {.python .cell-code}\nclass Node:\n    \"\"\" A struct to denote the node of a binary tree.\n    It contains a value and pointers to left and right children.\n    \"\"\"\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __ge__(self, other):\n        return self.value >= other.value\n\n\nleft = Node(4)\nroot = Node(5, left)\nprint(left == root) # False\nprint(left < root) # True\nprint(left >= root) # False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\nFalse\n```\n:::\n:::\n\n\nXem [ở đây](https://www.tutorialsteacher.com/python/magic-methods-in-python), hoặc [ở đây](https://docs.python.org/3/reference/datamodel.html#special-method-names) danh sách đầy đủ các magic method mà Python hỗ trợ.\n\nMột số magic method khác cần chú ý `__len__`, `__str__`, `__iter__`, and `__slots__` (tham khảo [đây](https://stackoverflow.com/questions/472000/usage-of-slots/28059785#28059785))\n\n# 5. Local namespace, object's attributes\n\n------------------------------------------------------------------------\n\nHàm `locals()` trả về danh sách các biến nằm trong local namespace:\n\n::: {#89777095 .cell execution_count=25}\n``` {.python .cell-code}\nclass Model1:\n    def __init__(self, hidden_size=100, num_layers=3, learning_rate=3e-4):\n        print(locals())\n        self.hidden_size = hidden_size\n        self.num_layers = num_layers\n        self.learning_rate = learning_rate\n\nmodel1 = Model1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'self': <__main__.Model1 object at 0x000001CF7DFDF210>, 'hidden_size': 100, 'num_layers': 3, 'learning_rate': 0.0003}\n```\n:::\n:::\n\n\nCác attributes của 1 object cũng được lưu hết trong `__dict__`:\n\n::: {#ba415bed .cell execution_count=26}\n``` {.python .cell-code}\nprint(model1.__dict__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'hidden_size': 100, 'num_layers': 3, 'learning_rate': 0.0003}\n```\n:::\n:::\n\n\nKhi có quá nhiều arguments, việc assign nó trong `__init__` trở nên phiền hà, chúng ta có thể làm như sau:\n\n::: {#79ea71bd .cell execution_count=27}\n``` {.python .cell-code}\nclass Model2:\n    def __init__(self, hidden_size=100, num_layers=3, learning_rate=3e-4):\n        params = locals()\n        del params['self']\n        self.__dict__ = params\n\nmodel2 = Model2()\nprint(model2.__dict__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'hidden_size': 100, 'num_layers': 3, 'learning_rate': 0.0003}\n```\n:::\n:::\n\n\nThậm chí rất tiện khi làm việc với `*kwargs`:\n\n::: {#cbdf61b5 .cell execution_count=28}\n``` {.python .cell-code}\nclass Model3:\n    def __init__(self, **kwargs):\n        self.__dict__ = kwargs\n\nmodel3 = Model3(hidden_size=100, num_layers=3, learning_rate=3e-4)\nprint(model3.__dict__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'hidden_size': 100, 'num_layers': 3, 'learning_rate': 0.0003}\n```\n:::\n:::\n\n\nĐọc thêm về `*args` và `*kwargs` ở [đây](https://manhhomienbienthuy.github.io/2019/09/20/python-args-kwargs.html).\n\n# 6. Wild Import\n\n------------------------------------------------------------------------\n\nChúng ta thường `import` tất cả như thế này:\n\n```{.python filename=\"file.py\"}\n#| eval: false\nfrom parts import *\n```\n\nSẽ là vô trách nhiệm khi chúng ta import toàn bộ module, ví dụ nếu `parts.py` có cấu trúc như thế này:\n\n```{.python filename=\"parts.py\"}\n#| eval: false\nimport numpy \nimport tensorflow \nclass Encoder: \n    ... \nclass Decoder: \n    ... \nclass Loss: \n    ... \ndef helper(*args, **kwargs): \n    ...\ndef utils(*args, **kwargs): \n    ... \n```\n\nVì `parts.py` không định nghĩa `__all__`, nên `file.py` sẽ import tất cả Encoder, Decoder, Loss, helper, untils cùng với numpy và tensorFlow. Nếu chỉ muốn import Encoder, Decoder, Loss, chúng ta nên làm như sau:\n\n```{.python filename=\"parts.py\"}\n#| eval: false\n__all__ = ['Encoder', 'Decoder', 'Loss'] \nimport numpy \nimport tensorflow \nclass Encoder: \n    ... \n```\n\nChúng ta có thể dùng `__all__` để tìm hiểu thành phần một module.\n\n# 7. Decorator to time your functions\n\n------------------------------------------------------------------------\n\nChúng ta thường muốn đo lường thời gian chạy của 1 function. Các tự nhiên thường dùng là đặt `time.time()` ở hai điểm đầu và cuối giữa các lệnh.\n\nVí dụ, với hàm tìm số Fibbonacci thứ n, với hai cách (1 cách sử dụng memoization).\n\n::: {#dce0a04f .cell execution_count=29}\n``` {.python .cell-code}\ndef fib_helper(n):\n    if n < 2:\n        return n\n    return fib_helper(n - 1) + fib_helper(n - 2)\n\ndef fib(n):\n    \"\"\" fib is a wrapper function so that later we can change its behavior\n    at the top level without affecting the behavior at every recursion step.\n    \"\"\"\n    return fib_helper(n)\n\ndef fib_m_helper(n, computed):\n    if n in computed:\n        return computed[n]\n    computed[n] = fib_m_helper(n - 1, computed) + fib_m_helper(n - 2, computed)\n    return computed[n]\n\ndef fib_m(n):\n    return fib_m_helper(n, {0: 0, 1: 1})\n```\n:::\n\n\nHãy chắc chắn `fib` và `fib_m` tương đương nhau:\n\n::: {#b87165b8 .cell execution_count=30}\n``` {.python .cell-code}\nfor n in range(20):\n    assert fib(n) == fib_m(n)\n```\n:::\n\n\nĐo lường thời gian chạy:\n\n::: {#348f554b .cell execution_count=31}\n``` {.python .cell-code}\nimport time\n\nstart = time.time()\nfib(30)\nprint(f'Without memoization, it takes {time.time() - start:7f} seconds.')\n\nstart = time.time()\nfib_m(30)\nprint(f'With memoization, it takes {time.time() - start:.7f} seconds.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWithout memoization, it takes 0.140998 seconds.\nWith memoization, it takes 0.0000000 seconds.\n```\n:::\n:::\n\n\nUsing decorator, define `timeit`:\n\n::: {#cd068f88 .cell execution_count=32}\n``` {.python .cell-code}\ndef timeit(fn): \n    # *args and **kwargs are to support positional and named arguments of fn\n    def get_time(*args, **kwargs): \n        start = time.time() \n        output = fn(*args, **kwargs)\n        print(f\"Time taken in {fn.__name__}: {time.time() - start:.7f}\")\n        return output  # make sure that the decorator returns the output of fn\n    return get_time \n```\n:::\n\n\nSau đó thêm `@timeit` tới function:\n\n::: {#e9f0a14b .cell execution_count=33}\n``` {.python .cell-code}\n@timeit\ndef fib(n):\n    return fib_helper(n)\n\n@timeit\ndef fib_m(n):\n    return fib_m_helper(n, {0: 0, 1: 1})\n\nfib(30)\nfib_m(30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime taken in fib: 0.1389999\nTime taken in fib_m: 0.0000000\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=67}\n```\n832040\n```\n:::\n:::\n\n\n# 8. Caching with `@functools.lru_cache`\n\n------------------------------------------------------------------------\n\n🚀Nguyên văn chị Huyền:\n> Memoization is a form of cache: we cache the previously calculated Fibonacci numbers so that we don't have to calculate them again.\n\n::: {#aed7e370 .cell execution_count=34}\n``` {.python .cell-code}\nimport functools\n\n@functools.lru_cache()\ndef fib_helper(n):\n    if n < 2:\n        return n\n    return fib_helper(n - 1) + fib_helper(n - 2)\n\n@timeit\ndef fib(n):\n    \"\"\" fib is a wrapper function so that later we can change its behavior\n    at the top level without affecting the behavior at every recursion step.\n    \"\"\"\n    return fib_helper(n)\n\nfib(50)\nfib_m(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime taken in fib: 0.0000000\nTime taken in fib_m: 0.0000000\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=68}\n```\n12586269025\n```\n:::\n:::\n\n\n`lru` stands for \"least recently used\". For more information on cache, see [here](https://docs.python.org/3/library/functools.html).\n\n# Reference\n\n------------------------------------------------------------------------\n\nSource: <https://github.com/chiphuyen/python-is-cool/tree/master>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}