{
  "hash": "ac758a945d6168ebf0530564367e3cfa",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python is cool ‚ùÑ\"\ndescription: \"Less-known Python features\"\nauthor:\n  - name: \"Tuan Le Khac\"\n    url: https://lktuan.github.io/\ndate: 05-21-2024\ncategories: [Python, Lambda] # self-defined categories\nimage: python.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n\nformat: \n  html: \n    code-fold: false\n    code-summary: \"Show the code\"\n    code-line-numbers: true\ncss: html/styles.scss\nfig-cap-location: bottom\neditor: visual\n---\n\n# 1. Motivation\n\n------------------------------------------------------------------------\n\nƒê√¢y l√† m·ªôt b√†i th·ª±c h√†nh theo m·ªôt [post](https://github.com/chiphuyen/python-is-cool/tree/master) b·ªüi ch·ªã [Chip Huyen](https://huyenchip.com/) v·ªÅ m·ªôt s·ªë features ƒë·∫∑c bi·ªát c·ªßa Python. L√† m·ªôt DA kh√¥ng s·ª≠ d·ª•ng Python qu√° nhi·ªÅu, ch·ªâ m·ªôt s·ªë feature d∆∞·ªõi ƒë√¢y l√† m√¨nh ƒë√£ t·ª´ng *nghe* qua. Hi v·ªçng b√†i th·ª±c h√†nh s·∫Ω gi√∫p m√¨nh h·ª©ng th√∫ v·ªõi Python h∆°n!\n\n::: {layout-ncol=1}\n![Dong Nai Cultural Nature Reserve, a python lying along the stream waiting for the prey. Photo credit to [PhucNguyenPhotos](https://www.instagram.com/vietnamphotos_herping/)](python.jpg){width=100%}\n:::\n\n\n# 2. Lambda, map, filter, & reduce\n\n------------------------------------------------------------------------\n\nLambda cho ph√©p ng∆∞·ªùi d√πng ƒë·ªãnh nghƒ©a in-line functions. Vi·ªác s·ª≠ d·ª•ng `lambda()` r·∫•t thu·∫≠n ti·ªán khi g·ªçi l·∫°i (callback \\~ m·ªôt function ƒë∆∞·ª£c th·ª±c thi sau khi m·ªôt function kh√°c ƒë∆∞·ª£c th·ª±c thi; m·ªôt c√°ch l∆∞u tr·ªØ function) ho·∫∑c khi ƒë·∫ßu ra c·ªßa m·ªôt function l√† ƒë·ªëi s·ªë cho m·ªôt function kh√°c.\n\nHai h√†m `square_fn` v√† `square_ld` d∆∞·ªõi ƒë√¢y l√† m·ªôt:\n\n::: {#e766fa15 .cell execution_count=1}\n``` {.python .cell-code}\ndef square_fn(x):\n    return x * x\n\nsquare_ld = lambda x : x * x\n\nfor i in range(10):\n    assert square_fn(i) == square_ld(i)\n```\n:::\n\n\n`lambda` r·∫•t h·ªØu √≠ch khi s·ª≠ d·ª•ng c√πng v·ªõi c√°c function kh√°c nh∆∞ `map`, `filter`, v√† `reduce` (m√¨nh r·∫•t hay s·ª≠ d·ª•ng pattern n√†y tr√™n Excel üòÇ). `map(fn, interable)` s·∫Ω apply h√†m `fn` cho t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ trong `iterable` (nh∆∞ list, set, dict, tuple, string), tr·∫£ v·ªÅ map object.\n\n::: {#748de3e3 .cell execution_count=2}\n``` {.python .cell-code}\nnums = [1/3, 2/7, 1001/37500, 40/27]\nnums_squared = [num * num for num in nums]\nprint(nums_squared)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.1111111111111111, 0.08163265306122448, 0.0007125340444444445, 2.194787379972565]\n```\n:::\n:::\n\n\nD√πng `map` v√† m·ªôt h√†m callback, cho ra k·∫øt qu·∫£ t∆∞∆°ng ƒë∆∞∆°ng:\n\n::: {#df4886fd .cell execution_count=3}\n``` {.python .cell-code}\nnums_squared_1 = map(square_fn, nums)\nnums_squared_2 = map(lambda x: x*x, nums)\nprint(list(nums_squared_1)) # list to list the elements of map object\nprint(list(nums_squared_2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.1111111111111111, 0.08163265306122448, 0.0007125340444444445, 2.194787379972565]\n[0.1111111111111111, 0.08163265306122448, 0.0007125340444444445, 2.194787379972565]\n```\n:::\n:::\n\n\nC√≥ th·ªÉ d√πng `map` v·ªõi nhi·ªÅu h∆°n 1 iterable. V√≠ d·ª• mu·ªën t√≠nh MSE cho m·ªôt h·ªìi quy tuy·∫øn t√≠nh ƒë∆°n gi·∫£n `f(x) = ax + b` v·ªõi ground tru `labels`, hai ph∆∞∆°ng ph√°p sau t∆∞∆°ng ƒë∆∞∆°ng:\n\n::: {#05b0305f .cell execution_count=4}\n``` {.python .cell-code}\na, b = 3, -0.5\nxs = [2, 3, 4, 5]\nlabels = [6.4, 8.9, 10.9, 15.3]\n\n# Ph∆∞∆°ng ph√°p 1, loop\nerrors = []\nfor i,x in enumerate(xs):\n    errors.append( (a * x + b - labels[i])**2 )\nresult_1 = sum(errors)**(1/2) / len(xs)\n\n# Ph∆∞∆°ng ph√°p 2, map\ndiff = map(lambda x, y: (a * x + b - y) ** 2, xs, labels) \nresult_2 = sum(diff)**.5 / len(xs)\n\nprint(result_1, result_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.35089172119045514 0.35089172119045514\n```\n:::\n:::\n\n\n`filter(fn, iterable)` gi·ªëng nh∆∞ `map`, tuy nhi√™n `fn` l√† m·ªôt h√†m tr·∫£ v·ªÅ gi√° tr·ªã boolean true/false, v√† `filter` s·∫Ω tr·∫£ v·ªÅ c√°c ph·∫ßn t·ª≠ c·ªßa `iterable` khi `fn` tr·∫£ v·ªÅ true.\n\n::: {#05c0aabd .cell execution_count=5}\n``` {.python .cell-code}\nbad_preds = filter(lambda x: x > 0.5, errors)\n\nprint(list(bad_preds))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.8100000000000006, 0.6400000000000011]\n```\n:::\n:::\n\n\n`reduce(fn, iterable, initializer)` ƒë∆∞·ª£c d√πng khi ta mu·ªën √°p d·ª•ng m·ªôt to√°n l√™n t·∫•t c·∫£ th√†nh ph·∫ßn trong danh s√°ch. V√≠ d·ª• mu·ªën t√≠nh k·∫øt qu·∫£ nh√¢n c·ªßa to√†n b·ªô ph·∫ßn t·ª≠:\n\n::: {#e93ccb12 .cell execution_count=6}\n``` {.python .cell-code}\nproduct = 1\nfor num in nums:\n    product *= num\nprint(product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.0037662551440329215\n```\n:::\n:::\n\n\nS·ª≠ d·ª•ng `reduce`:\n\n::: {#6a9343b3 .cell execution_count=7}\n``` {.python .cell-code}\nfrom functools import reduce\n\nproduct = reduce(lambda x, y: x * y, nums)\nprint(product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.0037662551440329215\n```\n:::\n:::\n\n\n### Hi·ªáu su·∫•t h√†m Lambda\n\nLambda ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ s·ª≠ d·ª•ng m·ªôt l·∫ßn. M·ªói l·∫ßn ƒë∆∞·ª£c g·ªçi, h√†m `lambda x: dosomething(x)` ƒë·ªÅu ƒë∆∞·ª£c t·∫°o l·∫°i, v√† do ƒë√≥ ·∫£nh h∆∞·ªüng t·ªõi hi·ªáu su·∫•t.\n\nKhi h√†m lambda ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a tr∆∞·ªõc `fn = lambda x: dosomething(x)`, hi·ªáu su·∫•t c·ªßa n√≥ v·∫´n ch·∫≠m h∆°n `def`, tuy nhi√™n kh√¥ng [ƒë√°ng k·ªÉ](https://stackoverflow.com/questions/26540885/lambda-is-slower-than-function-call-in-python-why).\n\nüöÄNguy√™n vƒÉn ch·ªã Chip:\n\n> Even though I find lambdas cool, I personally recommend using named functions when you can for the sake of clarity.\n\n# 3. List manipulation\n\n------------------------------------------------------------------------\n\n## 3.1. Unpacking\n\nCh√∫ng ta c√≥ th·ªÉ \"gi·∫£i n√©n\" m·ªôt list nh∆∞ th·∫ø n√†y:\n\n::: {#3a8e07f3 .cell execution_count=8}\n``` {.python .cell-code}\nelems = [1,2,3,4]\na,b,c,d = elems\n\nprint(a,b,c,d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2 3 4\n```\n:::\n:::\n\n\nC≈©ng c√≥ th·ªÉ l√†m nh∆∞ th·∫ø n√†y:\n\n::: {#b29723f4 .cell execution_count=9}\n``` {.python .cell-code}\na, *new_elems, d = elems # remember the char * for extended unpacking\n\nprint(a)\nprint(new_elems)\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n[2, 3]\n2\n```\n:::\n:::\n\n\n## 3.2. Slicing\n\nCh√∫ng ta c√≥ th·ªÉ reverse/ƒë·∫£o ng∆∞·ª£c m·ªôt list v·ªõi `[::-1]`\n\n::: {#5b66950c .cell execution_count=10}\n``` {.python .cell-code}\nelem = list(range(10))\nprint(elem)\n\n\nprint(elem[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n```\n:::\n:::\n\n\nC√∫ ph√°p `[x:y:z]` c√≥ nghƒ©a l√† l·∫•y ***m·ªói*** ph·∫ßn t·ª≠ th·ª© `z` t·ª´ index `x` t·ªõi index `y`. Khi `z` √¢m, t∆∞∆°ng ƒë∆∞∆°ng v·ªõi vi·ªác l·∫•y theo th·ª© t·ª± ng∆∞·ª£c l·∫°i. `x` ƒë·ªÉ tr·ªëng ch·ªâ vi·ªác l·∫•y t·ª´ ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n, `y` ƒë·ªÉ r·ªóng ch·ªâ vi·ªác l·∫•y t·ªõi ph·∫ßn t·ª≠ cu·ªëi c√πng.\n\n::: {#8450b96f .cell execution_count=11}\n``` {.python .cell-code}\nevens = elem[::2]\nprint(evens)\n\nreversed_evens = elem[2::-2]\nprint(reversed_evens)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 2, 4, 6, 8]\n[2, 0]\n```\n:::\n:::\n\n\nC≈©ng c√≥ th·ªÉ d√πng slicing ƒë·ªÉ x√≥a c√°c ph·∫ßn t·ª≠ nh∆∞ th·∫ø n√†y:\n\n::: {#6304b14e .cell execution_count=12}\n``` {.python .cell-code}\ndel elems[::2]\nprint(elems)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4]\n```\n:::\n:::\n\n\n## 3.3. Insertion\n\nCh√∫ng ta c√≥ th·ªÉ thay ƒë·ªïi gi√° tr·ªã m·ªôt ph·∫ßn t·ª≠ trong m·ªôt list nh∆∞ sau:\n\n::: {#09e7a085 .cell execution_count=13}\n``` {.python .cell-code}\nelems = list(range(10))\n\nelems[1] = 100\nprint(elems)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 100, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\nC≈©ng c√≥ th·ªÉ thay th·∫ø m·ªôt gi√° tr·ªã b·∫±ng nhi·ªÅu gi√° tr·ªã:\n\n::: {#54dadd82 .cell execution_count=14}\n``` {.python .cell-code}\nelems = list(range(10))\nelems[1:2] = [20, 30, 40]\nprint(elems)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 20, 30, 40, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\nN·∫øu ch√∫ng ta mu·ªën th√™m 3 gi√° tr·ªã `0.3, 0.4, 0.5` v√†o gi·ªØa ph·∫ßn t·ª≠ th·ª© 0 v√† 1 c·ªßa list n√†y, th√¨:\n\n::: {#8fcbcdc9 .cell execution_count=15}\n``` {.python .cell-code}\nelems = list(range(10))\nelems[1:1] = [.3, .4, .5]\nprint(elems)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 0.3, 0.4, 0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\n## 3.4. Flattening\n\nCh√∫ng ta c√≥ th·ªÉ flatten m·ªôt list s·ª≠ dung `sum(0)`:\n\n::: {#b917142a .cell execution_count=16}\n``` {.python .cell-code}\nlist_of_lists = [[1], [2, 3], [4, 5, 6]]\nsum(list_of_lists, [])\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n[1, 2, 3, 4, 5, 6]\n```\n:::\n:::\n\n\nC≈©ng c√≥ th·ªÉ s·ª≠ d·ª•ng recursive lambda (another beauty of lambda)\n\n::: {#49da237e .cell execution_count=17}\n``` {.python .cell-code}\nnested_lists = [[1, 2], [[3, 4], [5, 6], [[7, 8], [9, 10], [[11, [12, 13]]]]]]\nflatten = lambda x: [y for i in x for y in flatten(i)] if type(x) is list else [x]\n\nprint(flatten(nested_lists))\n\n# This line of code is from\n# https://github.com/sahands/python-by-example/blob/master/python-by-example.rst#flattening-lists\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n```\n:::\n:::\n\n\n## 3.5. List vs Generator\n\nüöÄGenerator l√† c√°i g√¨ v·∫≠y? Tr√≠ch [b√†i vi·∫øt](https://manhhomienbienthuy.github.io/2016/01/05/python-iterator-generator.html):\n\n> T·ª´ generator ƒë∆∞·ª£c s·ª≠ d·ª•ng cho c·∫£ h√†m (h√†m generator l√† h√†m ƒë√£ n√≥i ·ªü tr√™n) v√† k·∫øt qu·∫£ m√† h√†m ƒë√≥ sinh ra (ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c h√†m generator sinh ra c≈©ng ƒë∆∞·ª£c g·ªçi l√† generator). V√¨ v·∫≠y ƒë√¥i khi vi·ªác n√†y g√¢y kh√≥ hi·ªÉu m·ªôt ch√∫t. H√£y xem v√≠ d·ª• v·ªÅ vi·ªác t·∫°o n-grams t·ª´ m·ªôt danh s√°ch tokens d∆∞·ªõi ƒë√¢y ƒë·ªÉ hi·ªÉu s·ª± kh√°c bi·ªát gi·ªØa list v√† generator:\n\n::: {#ac58a93b .cell execution_count=18}\n``` {.python .cell-code}\ntokens = ['i', 'want', 'to', 'go', 'to', 'school']\n\ndef ngrams(tokens, n):\n    length = len(tokens)\n    grams = []\n    for i in range(length - n + 1):\n        grams.append(tokens[i:i+n])\n    return grams\n\nprint(ngrams(tokens, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[['i', 'want', 'to'], ['want', 'to', 'go'], ['to', 'go', 'to'], ['go', 'to', 'school']]\n```\n:::\n:::\n\n\nTrong v√≠ d·ª• n√†y, ch√∫ng ta ph·∫£i l∆∞u to√†n b·ªô n-grams m·ªôt l√∫c. N·∫øu c√≥ `m` tokens, memory requirement l√† `O(nm)` - s·∫Ω l√† v·∫•n ƒë·ªÅ n·∫øu `m` l·ªõn. Thay v√†o ƒë√≥, ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng generator ƒë·ªÉ t·∫°o n-grams ti·∫øp theo khi ƒë∆∞·ª£c y√™u c·∫ßu. ƒê√¢y g·ªçi l√† lazy evaluation. Ch√∫ng ta c√≥ th·ªÉ t·∫°o m·ªôt h√†m `ngrams` tr·∫£ v·ªÅ m·ªôt generator s·ª≠ d·ª•ng keyword `yield`, l√∫c n√†y memory requirement l√† `O(n+m)`.\n\n::: {#c4eeddbd .cell execution_count=19}\n``` {.python .cell-code}\ndef ngrams(tokens, n):\n    length = len(tokens)\n    for i in range(length - n + 1):\n        yield tokens[i:i+n]\n\nngrams_generator = ngrams(tokens, 3)\nprint(ngrams_generator)\n\nfor ngram in ngrams_generator:\n    print(ngram)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<generator object ngrams at 0x000001CF6CDBD210>\n['i', 'want', 'to']\n['want', 'to', 'go']\n['to', 'go', 'to']\n['go', 'to', 'school']\n```\n:::\n:::\n\n\nM·ªôt c√°ch kh√°c ƒë·ªÉ t·∫°o n-grams l√† slice ƒë·ªÉ l·∫•y c√°c sub-list `[0, 1, 2, ...,-n]`, `[1, 2, 3, ...,-n+1]`, `[2, 3, 4, ...,-n+2]`,... `[n-1, n, ...,-1]`, sau ƒë√≥ `zip` ch√∫ng l·∫°i:\n\n::: {#fa562b03 .cell execution_count=20}\n``` {.python .cell-code}\ndef ngrams(tokens, n):\n    length = len(tokens)\n    slices = (tokens[i:length-n+i+1] for i in range(n))\n    return zip(*slices)\n\nngrams_generator = ngrams(tokens, 3)\nprint(ngrams_generator)\n\n\nfor ngram in ngrams_generator:\n    print(ngram)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<zip object at 0x000001CF7DFDFFC0>\n('i', 'want', 'to')\n('want', 'to', 'go')\n('to', 'go', 'to')\n('go', 'to', 'school')\n```\n:::\n:::\n\n\nL∆∞u √Ω ch√∫ng ta s·ª≠ d·ª•ng `(tokens[...] for i in range(n))`, ch·ª© kh√¥ng ph·∫£i `[tokens[...] for i in range(n)]`. `[]` tr·∫£ v·ªÅ m·ªôt list, `()` tr·∫£ v·ªÅ generator. # 4. Classes & magic methods\n\n------------------------------------------------------------------------\n\nTrong Python, magic methods ƒë∆∞·ª£c prefixed v√† suffixed b·ªüi double underscore `__` (aka dunder). Magic method ƒë∆∞·ª£c bi·∫øt ƒë·∫øn r·ªông r√£i nh·∫•t l√† `__init__`.\n\n::: {#155f3d4d .cell execution_count=21}\n``` {.python .cell-code}\nclass Node:\n    \"\"\" A struct to denote the node of a binary tree.\n    It contains a value and pointers to left and right children.\n    \"\"\"\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n```\n:::\n\n\nIn ra object, tuy nhi√™n nh√¨n kh√¥ng t∆∞·ªùng minh l·∫Øm!\n\n::: {#fb664f0b .cell execution_count=22}\n``` {.python .cell-code}\nroot = Node(5)\nprint(root) # <__main__.Node object at 0x1069c4518>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<__main__.Node object at 0x000001CF7C26C550>\n```\n:::\n:::\n\n\nCh√∫ng ta mong mu·ªën khi in ra m·ªôt Node, gi√° tr·ªã c·ªßa n√≥ c≈©ng nh∆∞ gi√° tr·ªã c·ªßa c√°c Node con (n·∫øu c√≥) c≈©ng s·∫Ω ƒë∆∞·ª£c in ra. Ch√∫ng ta d√πng `__repr__`:\n\n::: {#b7dadb6e .cell execution_count=23}\n``` {.python .cell-code}\nclass Node:\n    \"\"\" A struct to denote the node of a binary tree.\n    It contains a value and pointers to left and right children.\n    \"\"\"\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        strings = [f'value: {self.value}']\n        strings.append(f'left: {self.left.value}' if self.left else 'left: None')\n        strings.append(f'right: {self.right.value}' if self.right else 'right: None')\n        return ', '.join(strings)\n\nleft = Node(4)\nroot = Node(5, left)\nprint(root) # value: 5, left: 4, right: None\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nvalue: 5, left: 4, right: None\n```\n:::\n:::\n\n\nCh√∫ng ta c≈©ng mu·ªën hai Node c√≥ th·ªÉ ƒë∆∞·ª£c so s√°nh ƒë∆∞·ª£c v·ªõi nhau, v√¨ th·∫ø t·∫°o ra c√°c magic method ƒë·ªÉ implement c√°c operator: `==` v·ªõi `__eq__`, `>` v·ªõi `__lt__`, '\\>=' v·ªõi `__ge__`:\n\n::: {#0d08bb90 .cell execution_count=24}\n``` {.python .cell-code}\nclass Node:\n    \"\"\" A struct to denote the node of a binary tree.\n    It contains a value and pointers to left and right children.\n    \"\"\"\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __ge__(self, other):\n        return self.value >= other.value\n\n\nleft = Node(4)\nroot = Node(5, left)\nprint(left == root) # False\nprint(left < root) # True\nprint(left >= root) # False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\nFalse\n```\n:::\n:::\n\n\nXem [·ªü ƒë√¢y](https://www.tutorialsteacher.com/python/magic-methods-in-python), ho·∫∑c [·ªü ƒë√¢y](https://docs.python.org/3/reference/datamodel.html#special-method-names) danh s√°ch ƒë·∫ßy ƒë·ªß c√°c magic method m√† Python h·ªó tr·ª£.\n\nM·ªôt s·ªë magic method kh√°c c·∫ßn ch√∫ √Ω `__len__`, `__str__`, `__iter__`, and `__slots__` (tham kh·∫£o [ƒë√¢y](https://stackoverflow.com/questions/472000/usage-of-slots/28059785#28059785))\n\n# 5. Local namespace, object's attributes\n\n------------------------------------------------------------------------\n\nH√†m `locals()` tr·∫£ v·ªÅ danh s√°ch c√°c bi·∫øn n·∫±m trong local namespace:\n\n::: {#89777095 .cell execution_count=25}\n``` {.python .cell-code}\nclass Model1:\n    def __init__(self, hidden_size=100, num_layers=3, learning_rate=3e-4):\n        print(locals())\n        self.hidden_size = hidden_size\n        self.num_layers = num_layers\n        self.learning_rate = learning_rate\n\nmodel1 = Model1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'self': <__main__.Model1 object at 0x000001CF7DFDF210>, 'hidden_size': 100, 'num_layers': 3, 'learning_rate': 0.0003}\n```\n:::\n:::\n\n\nC√°c attributes c·ªßa 1 object c≈©ng ƒë∆∞·ª£c l∆∞u h·∫øt trong `__dict__`:\n\n::: {#ba415bed .cell execution_count=26}\n``` {.python .cell-code}\nprint(model1.__dict__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'hidden_size': 100, 'num_layers': 3, 'learning_rate': 0.0003}\n```\n:::\n:::\n\n\nKhi c√≥ qu√° nhi·ªÅu arguments, vi·ªác assign n√≥ trong `__init__` tr·ªü n√™n phi·ªÅn h√†, ch√∫ng ta c√≥ th·ªÉ l√†m nh∆∞ sau:\n\n::: {#79ea71bd .cell execution_count=27}\n``` {.python .cell-code}\nclass Model2:\n    def __init__(self, hidden_size=100, num_layers=3, learning_rate=3e-4):\n        params = locals()\n        del params['self']\n        self.__dict__ = params\n\nmodel2 = Model2()\nprint(model2.__dict__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'hidden_size': 100, 'num_layers': 3, 'learning_rate': 0.0003}\n```\n:::\n:::\n\n\nTh·∫≠m ch√≠ r·∫•t ti·ªán khi l√†m vi·ªác v·ªõi `*kwargs`:\n\n::: {#cbdf61b5 .cell execution_count=28}\n``` {.python .cell-code}\nclass Model3:\n    def __init__(self, **kwargs):\n        self.__dict__ = kwargs\n\nmodel3 = Model3(hidden_size=100, num_layers=3, learning_rate=3e-4)\nprint(model3.__dict__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'hidden_size': 100, 'num_layers': 3, 'learning_rate': 0.0003}\n```\n:::\n:::\n\n\nƒê·ªçc th√™m v·ªÅ `*args` v√† `*kwargs` ·ªü [ƒë√¢y](https://manhhomienbienthuy.github.io/2019/09/20/python-args-kwargs.html).\n\n# 6. Wild Import\n\n------------------------------------------------------------------------\n\nCh√∫ng ta th∆∞·ªùng `import` t·∫•t c·∫£ nh∆∞ th·∫ø n√†y:\n\n```{.python filename=\"file.py\"}\n#| eval: false\nfrom parts import *\n```\n\nS·∫Ω l√† v√¥ tr√°ch nhi·ªám khi ch√∫ng ta import to√†n b·ªô module, v√≠ d·ª• n·∫øu `parts.py` c√≥ c·∫•u tr√∫c nh∆∞ th·∫ø n√†y:\n\n```{.python filename=\"parts.py\"}\n#| eval: false\nimport numpy \nimport tensorflow \nclass Encoder: \n    ... \nclass Decoder: \n    ... \nclass Loss: \n    ... \ndef helper(*args, **kwargs): \n    ...\ndef utils(*args, **kwargs): \n    ... \n```\n\nV√¨ `parts.py` kh√¥ng ƒë·ªãnh nghƒ©a `__all__`, n√™n `file.py` s·∫Ω import t·∫•t c·∫£ Encoder, Decoder, Loss, helper, untils c√πng v·ªõi numpy v√† tensorFlow. N·∫øu ch·ªâ mu·ªën import Encoder, Decoder, Loss, ch√∫ng ta n√™n l√†m nh∆∞ sau:\n\n```{.python filename=\"parts.py\"}\n#| eval: false\n__all__ = ['Encoder', 'Decoder', 'Loss'] \nimport numpy \nimport tensorflow \nclass Encoder: \n    ... \n```\n\nCh√∫ng ta c√≥ th·ªÉ d√πng `__all__` ƒë·ªÉ t√¨m hi·ªÉu th√†nh ph·∫ßn m·ªôt module.\n\n# 7. Decorator to time your functions\n\n------------------------------------------------------------------------\n\nCh√∫ng ta th∆∞·ªùng mu·ªën ƒëo l∆∞·ªùng th·ªùi gian ch·∫°y c·ªßa 1 function. C√°c t·ª± nhi√™n th∆∞·ªùng d√πng l√† ƒë·∫∑t `time.time()` ·ªü hai ƒëi·ªÉm ƒë·∫ßu v√† cu·ªëi gi·ªØa c√°c l·ªánh.\n\nV√≠ d·ª•, v·ªõi h√†m t√¨m s·ªë Fibbonacci th·ª© n, v·ªõi hai c√°ch (1 c√°ch s·ª≠ d·ª•ng memoization).\n\n::: {#dce0a04f .cell execution_count=29}\n``` {.python .cell-code}\ndef fib_helper(n):\n    if n < 2:\n        return n\n    return fib_helper(n - 1) + fib_helper(n - 2)\n\ndef fib(n):\n    \"\"\" fib is a wrapper function so that later we can change its behavior\n    at the top level without affecting the behavior at every recursion step.\n    \"\"\"\n    return fib_helper(n)\n\ndef fib_m_helper(n, computed):\n    if n in computed:\n        return computed[n]\n    computed[n] = fib_m_helper(n - 1, computed) + fib_m_helper(n - 2, computed)\n    return computed[n]\n\ndef fib_m(n):\n    return fib_m_helper(n, {0: 0, 1: 1})\n```\n:::\n\n\nH√£y ch·∫Øc ch·∫Øn `fib` v√† `fib_m` t∆∞∆°ng ƒë∆∞∆°ng nhau:\n\n::: {#b87165b8 .cell execution_count=30}\n``` {.python .cell-code}\nfor n in range(20):\n    assert fib(n) == fib_m(n)\n```\n:::\n\n\nƒêo l∆∞·ªùng th·ªùi gian ch·∫°y:\n\n::: {#348f554b .cell execution_count=31}\n``` {.python .cell-code}\nimport time\n\nstart = time.time()\nfib(30)\nprint(f'Without memoization, it takes {time.time() - start:7f} seconds.')\n\nstart = time.time()\nfib_m(30)\nprint(f'With memoization, it takes {time.time() - start:.7f} seconds.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWithout memoization, it takes 0.140998 seconds.\nWith memoization, it takes 0.0000000 seconds.\n```\n:::\n:::\n\n\nUsing decorator, define `timeit`:\n\n::: {#cd068f88 .cell execution_count=32}\n``` {.python .cell-code}\ndef timeit(fn): \n    # *args and **kwargs are to support positional and named arguments of fn\n    def get_time(*args, **kwargs): \n        start = time.time() \n        output = fn(*args, **kwargs)\n        print(f\"Time taken in {fn.__name__}: {time.time() - start:.7f}\")\n        return output  # make sure that the decorator returns the output of fn\n    return get_time \n```\n:::\n\n\nSau ƒë√≥ th√™m `@timeit` t·ªõi function:\n\n::: {#e9f0a14b .cell execution_count=33}\n``` {.python .cell-code}\n@timeit\ndef fib(n):\n    return fib_helper(n)\n\n@timeit\ndef fib_m(n):\n    return fib_m_helper(n, {0: 0, 1: 1})\n\nfib(30)\nfib_m(30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime taken in fib: 0.1389999\nTime taken in fib_m: 0.0000000\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=67}\n```\n832040\n```\n:::\n:::\n\n\n# 8. Caching with `@functools.lru_cache`\n\n------------------------------------------------------------------------\n\nüöÄNguy√™n vƒÉn ch·ªã Huy·ªÅn:\n> Memoization is a form of cache: we cache the previously calculated Fibonacci numbers so that we don't have to calculate them again.\n\n::: {#aed7e370 .cell execution_count=34}\n``` {.python .cell-code}\nimport functools\n\n@functools.lru_cache()\ndef fib_helper(n):\n    if n < 2:\n        return n\n    return fib_helper(n - 1) + fib_helper(n - 2)\n\n@timeit\ndef fib(n):\n    \"\"\" fib is a wrapper function so that later we can change its behavior\n    at the top level without affecting the behavior at every recursion step.\n    \"\"\"\n    return fib_helper(n)\n\nfib(50)\nfib_m(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime taken in fib: 0.0000000\nTime taken in fib_m: 0.0000000\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=68}\n```\n12586269025\n```\n:::\n:::\n\n\n`lru` stands for \"least recently used\". For more information on cache, see [here](https://docs.python.org/3/library/functools.html).\n\n# Reference\n\n------------------------------------------------------------------------\n\nSource: <https://github.com/chiphuyen/python-is-cool/tree/master>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}