{
  "hash": "1c82daca7f0ad717971150d4f692d791",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Bitcoin tour in Python\"\ndescription: \"Nhân việc thánh Andrej Karpathy ra ~~MV~~ [tutorial mới](https://www.youtube.com/watch?v=l8pRSuU81PU&t=9160s) về build GPT-2 from scratch, tôi lại ghé thăm trang web cá nhân của anh ấy.\"\nauthor:\n  - name: \"Tuan Le Khac\"\n    url: https://lktuan.github.io/\ndate: 06-10-2024\ndate-modified: 06-10-2024\ncategories: [crypto, bitcoin, python, andrej karpathy] \nimage: python_bitcoin.png\ndraft: false\ncss: html/styles.scss\nfig-cap-location: bottom\neditor: visual\ncode-fold: show\n---\n\nA from-scratch implementation of Bitcoin in Python under tuturial from Andrej Karpathy. \n\n# Motivation\n\nĐây là bài thực hành implement Bitcoin sử dụng Python mà tôi học được trên trang blog của Andrej Karpathy, nhà Khoa học máy tính, cựu Director mảng AI của Open AI.\n\n[Andrej Karpathy](https://karpathy.ai/) cho rằng blockchain đang giúp nới rộng trạng thái của ngành công nghiệp phát triển phần mềm, từ open source thành open source plus. Nghĩa là chúng ta đang không chỉ chia sẻ, công khai mã nguồn, mà còn cả tài nguyên. Và với tinh thần:\n\n> \"what I cannot create I do not understand\"\n\n, cách tốt nhất để học nó là thực hiện nó. Tôi cũng cho là thế!\n\n::: {layout-ncol=1}\n![Andrej Karpathy trong podcast với Lex Fridman](karpathy-podcast.jpg){width=100%}\n:::\n\nPhạm vi bài thực hành này là **tạo, ký số, phát hành các giao dịch Bitcoin thuần Python, từ con số 0, không thư viện phụ thuộc**.\n\nĐây là môi trường Python của mình:\n\n::: {#ae92cc42 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport sys\nprint(sys.version)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.11.4 (tags/v3.11.4:d2340ef, Jun  7 2023, 05:45:37) [MSC v.1934 64 bit (AMD64)]\n```\n:::\n:::\n\n\n# Step 1: generating a crypto identity\n\nĐầu tiên cần tạo ra Danh tính (identity) - một cặp private key / public key. Bitcoin sử dụng Hệ mật trên đường cong Elliptic (ECC) để bảo mật giao dịch [Xem thêm: 1. [Viblo](https://viblo.asia/p/gioi-thieu-ve-he-mat-tren-duong-cong-elliptic-ecc-XL6lA2PR5ek), 2. [Wiki](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography), quá khó cho tôi tại thời điểm bây giờ - nên tôi sẽ tạm bỏ qua, dù gì cũng cần phác thảo một khung tranh \"mờ mờ\" trước, việc vẽ chi tiết để sau.]{.aside}.\n\nĐây là tài liệu mà Andrej gợi ý cho chúng ta đọc về ECC: [blog post](https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/) của Andrea Corbellini.\n\nĐường cong $E: y^2 = x^3 + ax + b \\:(mod\\:p)$ trên trường hữu hạn $Z_p$ được xác định bởi 6 tham số $T = (p,a,b,G,n,h)$ sau:\n\n- $p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F$\n\n    $= 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1$\n\n    $= 2^{256} - 2^{32} - 977$\n\n-  $a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000$\n-  $b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007$\n\nVì được xác định trên $Z_p$, nên trên thực tế nó là một đường không liên lục, và trông sẽ như các điểm ngẫu nhiên trên một biểu đồ phân tán. Khi xác định trên trường số thực, EC sẽ trông như thế này:\n\n::: {layout-ncol=1}\n![[What does the curve used in Bitcoin, secp256k1, look like?](https://bitcoin.stackexchange.com/questions/21907/what-does-the-curve-used-in-bitcoin-secp256k1-look-like)](what_does_ec_look_like.png){width=100%}\n:::\n\nBài viết đầu tiên của [Andrea Corbellini](https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/) giới thiệu EC trên **trường số thực và luật nhóm**. Theo đó, với EC được xác định bằng $\\{(x,y)\\in R^2 | y^2 = x^3 + ax + b, 4a^3 + 27b^2 \\neq 0\\} \\cup \\{0\\}$ ($4a^3 + 27b^2 \\neq 0$ là để tránh điểm kỳ dị singular), cùng với các tiên đề về phép toán cộng ($+$) được trang bị gồm:\n\n1. Tính đóng (closure): nếu $a$ và $b$ thuộc $G$, thì $a+b$ cũng thuộc $G$;\n2. Tính kết hợp (associativity): $(a+b)+c = a + (b+c)$;\n3. Sự tồn tại của phần tử đơn vị (identity element 0): $a+0=0+a=a$;\n4. Tính khả nghịch (commutativity): với mọi $a$, tồn tại $b$ sao cho $a+b=0$;\n\nNếu chúng ta có thêm tính chất thứ 5 sau:\n\n5. Tính giao hoán (commutativity): $a+b = b+a$.\n\nThì nhóm đó được xem là một nhóm Abel. (Tập hợp các số nguyên $Z$ là một nhóm - Abel, còn tập hợp các số nguyên $N$ thì không phải như vậy).\n\nTập hợp các điểm trên EC là một nhóm Abel, do đó nó cũng có tính chất trên: có sự tồn tại của **phần tử đơn vị** 0 (cũng là vô hạn); phần tử **nghịch đảo** của $P$, ký hiệu $-P$, là điểm đối xứng của P qua trục hoành; **phép cộng** được định nghĩa như sau: với ba điểm $P$, $Q$, $R$ khác 0 và thẳng hàng trên EC, thì $P + Q + R = 0$, bất kể thứ tự của các điểm - ta thấy nó thỏa mãn các tính chất kết hợp và giao hoán của một nhóm Abel!.\n\nMình sẽ không đi chi tiết vào **phép cộng hình học** và **đại số**. Phép nhân vô hướng sẽ được trình bày ở phía sau. Mình chỉ cố gắng **hình dung** các tính chất của EC thông qua việc xem xét nó trên **trường số thực**.\n\nBlock code dưới đây định nghĩa đường cong EC. Bitcoin (hay Ethereum) sử dụng một đường cong theo tiêu chuẩn [secp256k1](https://en.bitcoin.it/wiki/Secp256k1) do *Viện Tiêu Chuẩn và Kỹ Thuật Quốc Gia Mỹ (NIST)* đặt ra.\n\n::: {#71960fdd .cell execution_count=2}\n``` {.python .cell-code}\n# from __future__ import annotations # PEP 563: Postponed evaluation of annotations\n# since my python version is 3.11.4 so no need to use future annotation feature which redefined since python 3.5\nfrom dataclasses import dataclass # replace constructor __init__, help us to easily declare class attributes.\n\n@dataclass\nclass Curve:\n    \"\"\"\n    Elliptic Curve over the field of integers modulo a prime.\n    Points on the curve satisfy y^2 = x^3 + a*x + b (mod p).\n\n    Z_p là một TẬP HỢP, khi p là số nguyên tố thì có thể coi nó là một TRƯỜNG https://forum.mathscope.org/archive/index.php/t-11835.html\n    \"\"\"\n    p: int # ta nói secp256k1 có đặc trưng p, được định trong trường Z_p\n    a: int\n    b: int\n\n# secp256k1 uses a = 0, b = 7, so we're dealing with the curve y^2 = x^3 + 7 (mod p)\nbitcoin_curve = Curve(\n    p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F,\n    a = 0x0000000000000000000000000000000000000000000000000000000000000000, # a = 0\n    b = 0x0000000000000000000000000000000000000000000000000000000000000007, # b = 7\n)\n```\n:::\n\n\nSau khi xác định curve, ta xác định generator (là một điểm dùng để khởi tạo quá trình \"walk\" trên đường cong)\n\n::: {#cc543cc9 .cell execution_count=3}\n``` {.python .cell-code}\n@dataclass\nclass Point:\n    \"\"\" Số nguyên tọa độ (x,y) trên đường cong \"\"\"\n    curve: Curve\n    x: int\n    y: int\n\nG = Point(\n    bitcoin_curve,\n    x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,\n    y = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,    \n)\n\n# xác nhận xem G có nằm trên đường cong hay không, tức là y^2 = x^3 + 7 (mod p)\nprint(\"G is on the curve:\", (G.y**2 - G.x**3 - 7) % bitcoin_curve.p == 0)\n\n# các giá trị bất kỳ khác HẦU NHƯ sẽ không nằm trên đường cong:\nimport random\nrandom.seed(1337)\nx = random.randrange(0, bitcoin_curve.p) # ngẫu nhiên giữa 0 và p\ny = random.randrange(0, bitcoin_curve.p)\nprint(\"G is on the curve:\", (y**2 - x**3 - 7) % bitcoin_curve.p == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nG is on the curve: True\nG is on the curve: False\n```\n:::\n:::\n\n\nSome notes to be updated here\n\n::: {#72b8b23e .cell execution_count=4}\n``` {.python .cell-code}\n@dataclass\nclass Generator:\n    \"\"\"\n    A Generator over a curve: an initial point and pre-declared order.\n    \"\"\"\n    G: Point # starting point on the curve\n    n: int # the order 0*G = n*G = INF (????)\n\nbitcoin_gen = Generator(\n    G = G,\n    # the order of G is known and can be mathematically derived\n    n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,\n)\n```\n:::\n\n\nNhư vậy đã định nghĩa xong Đường Cong, Điểm bắt đầu (`G`), và Trình tạo. Giờ ta sẽ tạo `private key` (hay `secret key`) - một số nguyên ngẫu nhiên thỏa `1<= key < n` (n đại diện cho order).\n\n::: {#8fdfd797 .cell execution_count=5}\n``` {.python .cell-code}\nsecret_key = int.from_bytes(b'Hi, this is Tuan', 'big') # this is how I will do it for reproducibility\nassert 1 <= secret_key < bitcoin_gen.n\nprint(secret_key)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n96250501864010348276735010787267273070\n```\n:::\n:::\n\n\nGiờ chúng ta sẽ tạo `public key`, chỉnh là cộng `G` `private key` lần.\n\n::: {#87482f66 .cell execution_count=6}\n``` {.python .cell-code}\nINF = Point(None, None, None) # special point at \"infinity\", kind of like a zero\n\ndef extended_euclidean_algorithm(a, b):\n    \"\"\"\n    Returns (gcd, x, y) s.t. a * x + b * y == gcd\n    This function implements the extended Euclidean\n    algorithm and runs in O(log b) in the worst case,\n    taken from Wikipedia.\n    \"\"\"\n    old_r, r = a, b\n    old_s, s = 1, 0\n    old_t, t = 0, 1\n    while r != 0:\n        quotient = old_r // r\n        old_r, r = r, old_r - quotient * r\n        old_s, s = s, old_s - quotient * s\n        old_t, t = t, old_t - quotient * t\n    return old_r, old_s, old_t\n\ndef inv(n, p):\n    \"\"\" returns modular multiplicate inverse m s.t. (n * m) % p == 1 \"\"\"\n    gcd, x, y = extended_euclidean_algorithm(n, p) # pylint: disable=unused-variable\n    return x % p\n\ndef elliptic_curve_addition(self, other: Point) -> Point:\n    # handle special case of P + 0 = 0 + P = 0\n    if self == INF:\n        return other\n    if other == INF:\n        return self\n    # handle special case of P + (-P) = 0\n    if self.x == other.x and self.y != other.y:\n        return INF\n    # compute the \"slope\"\n    if self.x == other.x: # (self.y = other.y is guaranteed too per above check)\n        m = (3 * self.x**2 + self.curve.a) * inv(2 * self.y, self.curve.p)\n    else:\n        m = (self.y - other.y) * inv(self.x - other.x, self.curve.p)\n    # compute the new point\n    rx = (m**2 - self.x - other.x) % self.curve.p\n    ry = (-(m*(rx - self.x) + self.y)) % self.curve.p\n    return Point(self.curve, rx, ry)\n\nPoint.__add__ = elliptic_curve_addition # monkey patch addition into the Point class\n```\n:::\n\n\nGiờ ta sẽ thử gen một số bộ `private key`, `public key`:\n\n::: {#2fab0960 .cell execution_count=7}\n``` {.python .cell-code}\n# if our secret key was the integer 1, then our public key would just be G:\n# use sk for secret key = private key\nsk = 1\npk = G\nprint(f\" secret key: {sk}\\n public key: {(pk.x, pk.y)}\")\nprint(\"Verify the public key is on the curve: \", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)\n# if it was 2, the public key is G + G:\nsk = 2\npk = G + G\nprint(f\" secret key: {sk}\\n public key: {(pk.x, pk.y)}\")\nprint(\"Verify the public key is on the curve: \", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)\n# etc.:\nsk = 3\npk = G + G + G\nprint(f\" secret key: {sk}\\n public key: {(pk.x, pk.y)}\")\nprint(\"Verify the public key is on the curve: \", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n secret key: 1\n public key: (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)\nVerify the public key is on the curve:  True\n secret key: 2\n public key: (89565891926547004231252920425935692360644145829622209833684329913297188986597, 12158399299693830322967808612713398636155367887041628176798871954788371653930)\nVerify the public key is on the curve:  True\n secret key: 3\n public key: (112711660439710606056748659173929673102114977341539408544630613555209775888121, 25583027980570883691656905877401976406448868254816295069919888960541586679410)\nVerify the public key is on the curve:  True\n```\n:::\n:::\n\n\nChúng ta cần tăng tốc việc công `G` với chính nó với số lần cực kì lớn, do đó Andrej sử dụng 1 thuật toán `double_and_add` như sau:\n\n::: {#7c1df0f5 .cell execution_count=8}\n``` {.python .cell-code}\ndef double_and_add(self, k: int) -> Point:\n    assert isinstance(k, int) and k >= 0\n    result = INF\n    append = self\n    while k:\n        if k & 1:\n            result += append\n        append += append\n        k >>= 1\n    return result\n\n# monkey patch double and add into the Point class for convenience\nPoint.__rmul__ = double_and_add\n\n# \"verify\" correctness\nprint(G == 1*G)\nprint(G + G == 2*G)\nprint(G + G + G == 3*G)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nTrue\n```\n:::\n:::\n\n\nGiờ test với `private_key` mà chúng ta tạo lúc đầu:\n\n::: {#088f88d2 .cell execution_count=9}\n``` {.python .cell-code}\n# efficiently calculate our actual public key!\npublic_key = secret_key * G\nprint(f\"x: {public_key.x}\\ny: {public_key.y}\")\nprint(\"Verify the public key is on the curve: \", (public_key.y**2 - public_key.x**3 - 7) % bitcoin_curve.p == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx: 95402322600731393781298762734940467224395293762704745012558525900395478371250\ny: 53299222514341331201918874000650944949613849271347665849281678080211837503484\nVerify the public key is on the curve:  True\n```\n:::\n:::\n\n\n**🚀Đã được modulized ở** [`curves.py`]()\n\nVới cặp private/public key ta đã implement được khả năng định danh cho Bitcoin. Giờ ta cần liên kết nó với địa chỉ ví. Trước hết ta cần triển khai một số hàm hash.\n\nCó thể sử dụng `hashlib` của Python tuy nhiên Andrej không muốn sử dụng thư viện phụ thuộc. Andrej đã viết lại hai hàm hash mà Bitcoin sử dụng là `SHA-256` và `RIPEMD-160`, lần lượt dưới đây, mình note giải thích của Andrej ở phần code comment.\n\nCó lẽ sẽ cần một dịp khác để hiểu hai hàm băm này, nó nằm ngoài khả năng của mình.\n\n::: {#74935684 .cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\ndef gen_sha256_with_variable_scope_protector_to_not_pollute_global_namespace():\n\n    \"\"\"\n    SHA256 implementation.\n\n    Follows the FIPS PUB 180-4 description for calculating SHA-256 hash function\n    https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\n\n    Noone in their right mind should use this for any serious reason. This was written\n    purely for educational purposes.\n    \"\"\"\n\n    import math\n    from itertools import count, islice\n\n    # -----------------------------------------------------------------------------\n    # SHA-256 Functions, defined in Section 4\n\n    def rotr(x, n, size=32):\n        return (x >> n) | (x << size - n) & (2**size - 1)\n\n    def shr(x, n):\n        return x >> n\n\n    def sig0(x):\n        return rotr(x, 7) ^ rotr(x, 18) ^ shr(x, 3)\n\n    def sig1(x):\n        return rotr(x, 17) ^ rotr(x, 19) ^ shr(x, 10)\n\n    def capsig0(x):\n        return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)\n\n    def capsig1(x):\n        return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)\n\n    def ch(x, y, z):\n        return (x & y)^ (~x & z)\n\n    def maj(x, y, z):\n        return (x & y) ^ (x & z) ^ (y & z)\n\n    def b2i(b):\n        return int.from_bytes(b, 'big')\n\n    def i2b(i):\n        return i.to_bytes(4, 'big')\n\n    # -----------------------------------------------------------------------------\n    # SHA-256 Constants\n\n    def is_prime(n):\n        return not any(f for f in range(2,int(math.sqrt(n))+1) if n%f == 0)\n\n    def first_n_primes(n):\n        return islice(filter(is_prime, count(start=2)), n)\n\n    def frac_bin(f, n=32):\n        \"\"\" return the first n bits of fractional part of float f \"\"\"\n        f -= math.floor(f) # get only the fractional part\n        f *= 2**n # shift left\n        f = int(f) # truncate the rest of the fractional content\n        return f\n\n    def genK():\n        \"\"\"\n        Follows Section 4.2.2 to generate K\n\n        The first 32 bits of the fractional parts of the cube roots of the first\n        64 prime numbers:\n\n        428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5\n        d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174\n        e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da\n        983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967\n        27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85\n        a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070\n        19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3\n        748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2\n        \"\"\"\n        return [frac_bin(p ** (1/3.0)) for p in first_n_primes(64)]\n\n    def genH():\n        \"\"\"\n        Follows Section 5.3.3 to generate the initial hash value H^0\n\n        The first 32 bits of the fractional parts of the square roots of\n        the first 8 prime numbers.\n\n        6a09e667 bb67ae85 3c6ef372 a54ff53a 9b05688c 510e527f 1f83d9ab 5be0cd19\n        \"\"\"\n        return [frac_bin(p ** (1/2.0)) for p in first_n_primes(8)]\n\n    # -----------------------------------------------------------------------------\n\n    def pad(b):\n        \"\"\" Follows Section 5.1: Padding the message \"\"\"\n        b = bytearray(b) # convert to a mutable equivalent\n        l = len(b) * 8 # note: len returns number of bytes not bits\n\n        # append but \"1\" to the end of the message\n        b.append(0b10000000) # appending 10000000 in binary (=128 in decimal)\n\n        # follow by k zero bits, where k is the smallest non-negative solution to\n        # l + 1 + k = 448 mod 512\n        # i.e. pad with zeros until we reach 448 (mod 512)\n        while (len(b)*8) % 512 != 448:\n            b.append(0x00)\n\n        # the last 64-bit block is the length l of the original message\n        # expressed in binary (big endian)\n        b.extend(l.to_bytes(8, 'big'))\n\n        return b\n\n    def sha256(b: bytes) -> bytes:\n\n        # Section 4.2\n        K = genK()\n\n        # Section 5: Preprocessing\n        # Section 5.1: Pad the message\n        b = pad(b)\n        # Section 5.2: Separate the message into blocks of 512 bits (64 bytes)\n        blocks = [b[i:i+64] for i in range(0, len(b), 64)]\n\n        # for each message block M^1 ... M^N\n        H = genH() # Section 5.3\n\n        # Section 6\n        for M in blocks: # each block is a 64-entry array of 8-bit bytes\n\n            # 1. Prepare the message schedule, a 64-entry array of 32-bit words\n            W = []\n            for t in range(64):\n                if t <= 15:\n                    # the first 16 words are just a copy of the block\n                    W.append(bytes(M[t*4:t*4+4]))\n                else:\n                    term1 = sig1(b2i(W[t-2]))\n                    term2 = b2i(W[t-7])\n                    term3 = sig0(b2i(W[t-15]))\n                    term4 = b2i(W[t-16])\n                    total = (term1 + term2 + term3 + term4) % 2**32\n                    W.append(i2b(total))\n\n            # 2. Initialize the 8 working variables a,b,c,d,e,f,g,h with prev hash value\n            a, b, c, d, e, f, g, h = H\n\n            # 3.\n            for t in range(64):\n                T1 = (h + capsig1(e) + ch(e, f, g) + K[t] + b2i(W[t])) % 2**32\n                T2 = (capsig0(a) + maj(a, b, c)) % 2**32\n                h = g\n                g = f\n                f = e\n                e = (d + T1) % 2**32\n                d = c\n                c = b\n                b = a\n                a = (T1 + T2) % 2**32\n\n            # 4. Compute the i-th intermediate hash value H^i\n            delta = [a, b, c, d, e, f, g, h]\n            H = [(i1 + i2) % 2**32 for i1, i2 in zip(H, delta)]\n\n        return b''.join(i2b(i) for i in H)\n\n    return sha256\n\nsha256 = gen_sha256_with_variable_scope_protector_to_not_pollute_global_namespace()\nprint(\"verify empty hash:\", sha256(b'').hex()) # should be e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\nprint(sha256(b'here is a random bytes message, cool right?').hex())\nprint(\"number of bytes in a sha256 digest: \", len(sha256(b'')))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nverify empty hash: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n69b9779edaa573a509999cbae415d3408c30544bad09727a1d64eff353c95b89\nnumber of bytes in a sha256 digest:  32\n```\n:::\n:::\n\n\nHàm băm thứ hai là `RIPEMD-160`:\n\n::: {#05de01e2 .cell execution_count=11}\n``` {.python .cell-code code-fold=\"true\"}\ndef gen_ripemd160_with_variable_scope_protector_to_not_pollute_global_namespace():\n\n    import sys\n    import struct\n\n    # -----------------------------------------------------------------------------\n    # public interface\n\n    def ripemd160(b: bytes) -> bytes:\n        \"\"\" simple wrapper for a simpler API to this hash function, just bytes to bytes \"\"\"\n        ctx = RMDContext()\n        RMD160Update(ctx, b, len(b))\n        digest = RMD160Final(ctx)\n        return digest\n\n    # -----------------------------------------------------------------------------\n\n    class RMDContext:\n        def __init__(self):\n            self.state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0] # uint32\n            self.count = 0 # uint64\n            self.buffer = [0]*64 # uchar\n\n    def RMD160Update(ctx, inp, inplen):\n        have = int((ctx.count // 8) % 64)\n        inplen = int(inplen)\n        need = 64 - have\n        ctx.count += 8 * inplen\n        off = 0\n        if inplen >= need:\n            if have:\n                for i in range(need):\n                    ctx.buffer[have+i] = inp[i]\n                RMD160Transform(ctx.state, ctx.buffer)\n                off = need\n                have = 0\n            while off + 64 <= inplen:\n                RMD160Transform(ctx.state, inp[off:])\n                off += 64\n        if off < inplen:\n            for i in range(inplen - off):\n                ctx.buffer[have+i] = inp[off+i]\n\n    def RMD160Final(ctx):\n        size = struct.pack(\"<Q\", ctx.count)\n        padlen = 64 - ((ctx.count // 8) % 64)\n        if padlen < 1 + 8:\n            padlen += 64\n        RMD160Update(ctx, PADDING, padlen-8)\n        RMD160Update(ctx, size, 8)\n        return struct.pack(\"<5L\", *ctx.state)\n\n    # -----------------------------------------------------------------------------\n\n    K0 = 0x00000000\n    K1 = 0x5A827999\n    K2 = 0x6ED9EBA1\n    K3 = 0x8F1BBCDC\n    K4 = 0xA953FD4E\n    KK0 = 0x50A28BE6\n    KK1 = 0x5C4DD124\n    KK2 = 0x6D703EF3\n    KK3 = 0x7A6D76E9\n    KK4 = 0x00000000\n\n    PADDING = [0x80] + [0]*63\n\n    def ROL(n, x):\n        return ((x << n) & 0xffffffff) | (x >> (32 - n))\n\n    def F0(x, y, z):\n        return x ^ y ^ z\n\n    def F1(x, y, z):\n        return (x & y) | (((~x) % 0x100000000) & z)\n\n    def F2(x, y, z):\n        return (x | ((~y) % 0x100000000)) ^ z\n\n    def F3(x, y, z):\n        return (x & z) | (((~z) % 0x100000000) & y)\n\n    def F4(x, y, z):\n        return x ^ (y | ((~z) % 0x100000000))\n\n    def R(a, b, c, d, e, Fj, Kj, sj, rj, X):\n        a = ROL(sj, (a + Fj(b, c, d) + X[rj] + Kj) % 0x100000000) + e\n        c = ROL(10, c)\n        return a % 0x100000000, c\n\n    def RMD160Transform(state, block): #uint32 state[5], uchar block[64]\n\n        x = [0]*16\n        assert sys.byteorder == 'little', \"Only little endian is supported atm for RIPEMD160\"\n        x = struct.unpack('<16L', bytes(block[0:64]))\n\n        a = state[0]\n        b = state[1]\n        c = state[2]\n        d = state[3]\n        e = state[4]\n\n        #/* Round 1 */\n        a, c = R(a, b, c, d, e, F0, K0, 11,  0, x)\n        e, b = R(e, a, b, c, d, F0, K0, 14,  1, x)\n        d, a = R(d, e, a, b, c, F0, K0, 15,  2, x)\n        c, e = R(c, d, e, a, b, F0, K0, 12,  3, x)\n        b, d = R(b, c, d, e, a, F0, K0,  5,  4, x)\n        a, c = R(a, b, c, d, e, F0, K0,  8,  5, x)\n        e, b = R(e, a, b, c, d, F0, K0,  7,  6, x)\n        d, a = R(d, e, a, b, c, F0, K0,  9,  7, x)\n        c, e = R(c, d, e, a, b, F0, K0, 11,  8, x)\n        b, d = R(b, c, d, e, a, F0, K0, 13,  9, x)\n        a, c = R(a, b, c, d, e, F0, K0, 14, 10, x)\n        e, b = R(e, a, b, c, d, F0, K0, 15, 11, x)\n        d, a = R(d, e, a, b, c, F0, K0,  6, 12, x)\n        c, e = R(c, d, e, a, b, F0, K0,  7, 13, x)\n        b, d = R(b, c, d, e, a, F0, K0,  9, 14, x)\n        a, c = R(a, b, c, d, e, F0, K0,  8, 15, x) #/* #15 */\n        #/* Round 2 */\n        e, b = R(e, a, b, c, d, F1, K1,  7,  7, x)\n        d, a = R(d, e, a, b, c, F1, K1,  6,  4, x)\n        c, e = R(c, d, e, a, b, F1, K1,  8, 13, x)\n        b, d = R(b, c, d, e, a, F1, K1, 13,  1, x)\n        a, c = R(a, b, c, d, e, F1, K1, 11, 10, x)\n        e, b = R(e, a, b, c, d, F1, K1,  9,  6, x)\n        d, a = R(d, e, a, b, c, F1, K1,  7, 15, x)\n        c, e = R(c, d, e, a, b, F1, K1, 15,  3, x)\n        b, d = R(b, c, d, e, a, F1, K1,  7, 12, x)\n        a, c = R(a, b, c, d, e, F1, K1, 12,  0, x)\n        e, b = R(e, a, b, c, d, F1, K1, 15,  9, x)\n        d, a = R(d, e, a, b, c, F1, K1,  9,  5, x)\n        c, e = R(c, d, e, a, b, F1, K1, 11,  2, x)\n        b, d = R(b, c, d, e, a, F1, K1,  7, 14, x)\n        a, c = R(a, b, c, d, e, F1, K1, 13, 11, x)\n        e, b = R(e, a, b, c, d, F1, K1, 12,  8, x) #/* #31 */\n        #/* Round 3 */\n        d, a = R(d, e, a, b, c, F2, K2, 11,  3, x)\n        c, e = R(c, d, e, a, b, F2, K2, 13, 10, x)\n        b, d = R(b, c, d, e, a, F2, K2,  6, 14, x)\n        a, c = R(a, b, c, d, e, F2, K2,  7,  4, x)\n        e, b = R(e, a, b, c, d, F2, K2, 14,  9, x)\n        d, a = R(d, e, a, b, c, F2, K2,  9, 15, x)\n        c, e = R(c, d, e, a, b, F2, K2, 13,  8, x)\n        b, d = R(b, c, d, e, a, F2, K2, 15,  1, x)\n        a, c = R(a, b, c, d, e, F2, K2, 14,  2, x)\n        e, b = R(e, a, b, c, d, F2, K2,  8,  7, x)\n        d, a = R(d, e, a, b, c, F2, K2, 13,  0, x)\n        c, e = R(c, d, e, a, b, F2, K2,  6,  6, x)\n        b, d = R(b, c, d, e, a, F2, K2,  5, 13, x)\n        a, c = R(a, b, c, d, e, F2, K2, 12, 11, x)\n        e, b = R(e, a, b, c, d, F2, K2,  7,  5, x)\n        d, a = R(d, e, a, b, c, F2, K2,  5, 12, x) #/* #47 */\n        #/* Round 4 */\n        c, e = R(c, d, e, a, b, F3, K3, 11,  1, x)\n        b, d = R(b, c, d, e, a, F3, K3, 12,  9, x)\n        a, c = R(a, b, c, d, e, F3, K3, 14, 11, x)\n        e, b = R(e, a, b, c, d, F3, K3, 15, 10, x)\n        d, a = R(d, e, a, b, c, F3, K3, 14,  0, x)\n        c, e = R(c, d, e, a, b, F3, K3, 15,  8, x)\n        b, d = R(b, c, d, e, a, F3, K3,  9, 12, x)\n        a, c = R(a, b, c, d, e, F3, K3,  8,  4, x)\n        e, b = R(e, a, b, c, d, F3, K3,  9, 13, x)\n        d, a = R(d, e, a, b, c, F3, K3, 14,  3, x)\n        c, e = R(c, d, e, a, b, F3, K3,  5,  7, x)\n        b, d = R(b, c, d, e, a, F3, K3,  6, 15, x)\n        a, c = R(a, b, c, d, e, F3, K3,  8, 14, x)\n        e, b = R(e, a, b, c, d, F3, K3,  6,  5, x)\n        d, a = R(d, e, a, b, c, F3, K3,  5,  6, x)\n        c, e = R(c, d, e, a, b, F3, K3, 12,  2, x) #/* #63 */\n        #/* Round 5 */\n        b, d = R(b, c, d, e, a, F4, K4,  9,  4, x)\n        a, c = R(a, b, c, d, e, F4, K4, 15,  0, x)\n        e, b = R(e, a, b, c, d, F4, K4,  5,  5, x)\n        d, a = R(d, e, a, b, c, F4, K4, 11,  9, x)\n        c, e = R(c, d, e, a, b, F4, K4,  6,  7, x)\n        b, d = R(b, c, d, e, a, F4, K4,  8, 12, x)\n        a, c = R(a, b, c, d, e, F4, K4, 13,  2, x)\n        e, b = R(e, a, b, c, d, F4, K4, 12, 10, x)\n        d, a = R(d, e, a, b, c, F4, K4,  5, 14, x)\n        c, e = R(c, d, e, a, b, F4, K4, 12,  1, x)\n        b, d = R(b, c, d, e, a, F4, K4, 13,  3, x)\n        a, c = R(a, b, c, d, e, F4, K4, 14,  8, x)\n        e, b = R(e, a, b, c, d, F4, K4, 11, 11, x)\n        d, a = R(d, e, a, b, c, F4, K4,  8,  6, x)\n        c, e = R(c, d, e, a, b, F4, K4,  5, 15, x)\n        b, d = R(b, c, d, e, a, F4, K4,  6, 13, x) #/* #79 */\n\n        aa = a\n        bb = b\n        cc = c\n        dd = d\n        ee = e\n\n        a = state[0]\n        b = state[1]\n        c = state[2]\n        d = state[3]\n        e = state[4]\n\n        #/* Parallel round 1 */\n        a, c = R(a, b, c, d, e, F4, KK0,  8,  5, x)\n        e, b = R(e, a, b, c, d, F4, KK0,  9, 14, x)\n        d, a = R(d, e, a, b, c, F4, KK0,  9,  7, x)\n        c, e = R(c, d, e, a, b, F4, KK0, 11,  0, x)\n        b, d = R(b, c, d, e, a, F4, KK0, 13,  9, x)\n        a, c = R(a, b, c, d, e, F4, KK0, 15,  2, x)\n        e, b = R(e, a, b, c, d, F4, KK0, 15, 11, x)\n        d, a = R(d, e, a, b, c, F4, KK0,  5,  4, x)\n        c, e = R(c, d, e, a, b, F4, KK0,  7, 13, x)\n        b, d = R(b, c, d, e, a, F4, KK0,  7,  6, x)\n        a, c = R(a, b, c, d, e, F4, KK0,  8, 15, x)\n        e, b = R(e, a, b, c, d, F4, KK0, 11,  8, x)\n        d, a = R(d, e, a, b, c, F4, KK0, 14,  1, x)\n        c, e = R(c, d, e, a, b, F4, KK0, 14, 10, x)\n        b, d = R(b, c, d, e, a, F4, KK0, 12,  3, x)\n        a, c = R(a, b, c, d, e, F4, KK0,  6, 12, x) #/* #15 */\n        #/* Parallel round 2 */\n        e, b = R(e, a, b, c, d, F3, KK1,  9,  6, x)\n        d, a = R(d, e, a, b, c, F3, KK1, 13, 11, x)\n        c, e = R(c, d, e, a, b, F3, KK1, 15,  3, x)\n        b, d = R(b, c, d, e, a, F3, KK1,  7,  7, x)\n        a, c = R(a, b, c, d, e, F3, KK1, 12,  0, x)\n        e, b = R(e, a, b, c, d, F3, KK1,  8, 13, x)\n        d, a = R(d, e, a, b, c, F3, KK1,  9,  5, x)\n        c, e = R(c, d, e, a, b, F3, KK1, 11, 10, x)\n        b, d = R(b, c, d, e, a, F3, KK1,  7, 14, x)\n        a, c = R(a, b, c, d, e, F3, KK1,  7, 15, x)\n        e, b = R(e, a, b, c, d, F3, KK1, 12,  8, x)\n        d, a = R(d, e, a, b, c, F3, KK1,  7, 12, x)\n        c, e = R(c, d, e, a, b, F3, KK1,  6,  4, x)\n        b, d = R(b, c, d, e, a, F3, KK1, 15,  9, x)\n        a, c = R(a, b, c, d, e, F3, KK1, 13,  1, x)\n        e, b = R(e, a, b, c, d, F3, KK1, 11,  2, x) #/* #31 */\n        #/* Parallel round 3 */\n        d, a = R(d, e, a, b, c, F2, KK2,  9, 15, x)\n        c, e = R(c, d, e, a, b, F2, KK2,  7,  5, x)\n        b, d = R(b, c, d, e, a, F2, KK2, 15,  1, x)\n        a, c = R(a, b, c, d, e, F2, KK2, 11,  3, x)\n        e, b = R(e, a, b, c, d, F2, KK2,  8,  7, x)\n        d, a = R(d, e, a, b, c, F2, KK2,  6, 14, x)\n        c, e = R(c, d, e, a, b, F2, KK2,  6,  6, x)\n        b, d = R(b, c, d, e, a, F2, KK2, 14,  9, x)\n        a, c = R(a, b, c, d, e, F2, KK2, 12, 11, x)\n        e, b = R(e, a, b, c, d, F2, KK2, 13,  8, x)\n        d, a = R(d, e, a, b, c, F2, KK2,  5, 12, x)\n        c, e = R(c, d, e, a, b, F2, KK2, 14,  2, x)\n        b, d = R(b, c, d, e, a, F2, KK2, 13, 10, x)\n        a, c = R(a, b, c, d, e, F2, KK2, 13,  0, x)\n        e, b = R(e, a, b, c, d, F2, KK2,  7,  4, x)\n        d, a = R(d, e, a, b, c, F2, KK2,  5, 13, x) #/* #47 */\n        #/* Parallel round 4 */\n        c, e = R(c, d, e, a, b, F1, KK3, 15,  8, x)\n        b, d = R(b, c, d, e, a, F1, KK3,  5,  6, x)\n        a, c = R(a, b, c, d, e, F1, KK3,  8,  4, x)\n        e, b = R(e, a, b, c, d, F1, KK3, 11,  1, x)\n        d, a = R(d, e, a, b, c, F1, KK3, 14,  3, x)\n        c, e = R(c, d, e, a, b, F1, KK3, 14, 11, x)\n        b, d = R(b, c, d, e, a, F1, KK3,  6, 15, x)\n        a, c = R(a, b, c, d, e, F1, KK3, 14,  0, x)\n        e, b = R(e, a, b, c, d, F1, KK3,  6,  5, x)\n        d, a = R(d, e, a, b, c, F1, KK3,  9, 12, x)\n        c, e = R(c, d, e, a, b, F1, KK3, 12,  2, x)\n        b, d = R(b, c, d, e, a, F1, KK3,  9, 13, x)\n        a, c = R(a, b, c, d, e, F1, KK3, 12,  9, x)\n        e, b = R(e, a, b, c, d, F1, KK3,  5,  7, x)\n        d, a = R(d, e, a, b, c, F1, KK3, 15, 10, x)\n        c, e = R(c, d, e, a, b, F1, KK3,  8, 14, x) #/* #63 */\n        #/* Parallel round 5 */\n        b, d = R(b, c, d, e, a, F0, KK4,  8, 12, x)\n        a, c = R(a, b, c, d, e, F0, KK4,  5, 15, x)\n        e, b = R(e, a, b, c, d, F0, KK4, 12, 10, x)\n        d, a = R(d, e, a, b, c, F0, KK4,  9,  4, x)\n        c, e = R(c, d, e, a, b, F0, KK4, 12,  1, x)\n        b, d = R(b, c, d, e, a, F0, KK4,  5,  5, x)\n        a, c = R(a, b, c, d, e, F0, KK4, 14,  8, x)\n        e, b = R(e, a, b, c, d, F0, KK4,  6,  7, x)\n        d, a = R(d, e, a, b, c, F0, KK4,  8,  6, x)\n        c, e = R(c, d, e, a, b, F0, KK4, 13,  2, x)\n        b, d = R(b, c, d, e, a, F0, KK4,  6, 13, x)\n        a, c = R(a, b, c, d, e, F0, KK4,  5, 14, x)\n        e, b = R(e, a, b, c, d, F0, KK4, 15,  0, x)\n        d, a = R(d, e, a, b, c, F0, KK4, 13,  3, x)\n        c, e = R(c, d, e, a, b, F0, KK4, 11,  9, x)\n        b, d = R(b, c, d, e, a, F0, KK4, 11, 11, x) #/* #79 */\n\n        t = (state[1] + cc + d) % 0x100000000\n        state[1] = (state[2] + dd + e) % 0x100000000\n        state[2] = (state[3] + ee + a) % 0x100000000\n        state[3] = (state[4] + aa + b) % 0x100000000\n        state[4] = (state[0] + bb + c) % 0x100000000\n        state[0] = t % 0x100000000\n\n    return ripemd160\n\nripemd160 = gen_ripemd160_with_variable_scope_protector_to_not_pollute_global_namespace()\nprint(ripemd160(b'hello this is a test').hex())\nprint(\"number of bytes in a RIPEMD-160 digest: \", len(ripemd160(b'')))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nf51960af7dd4813a587ab26388ddab3b28d1f7b4\nnumber of bytes in a RIPEMD-160 digest:  20\n```\n:::\n:::\n\n\nOk giờ thì có thể làm việc với Bitcoin Address. Chúng ta sẽ tạo một class `PublicKet`, là con của `Point`, cũng là một điểm trên `Curve`.\n\n::: {#29c34bfd .cell execution_count=12}\n``` {.python .cell-code}\nclass PublicKey(Point):\n    \"\"\"\n    The public key is just a Point on a Curve, but has some additional specific\n    encoding / decoding functionality that this class implements.\n    \"\"\"\n\n    @classmethod\n    def from_point(cls, pt: Point):\n        \"\"\" promote a Point to be a PublicKey \"\"\"\n        return cls(pt.curve, pt.x, pt.y)\n\n    def encode(self, compressed, hash160=False):\n        \"\"\" return the SEC bytes encoding of the public key Point \"\"\"\n        # calculate the bytes\n        if compressed:\n            # (x,y) is very redundant. Because y^2 = x^3 + 7,\n            # we can just encode x, and then y = +/- sqrt(x^3 + 7),\n            # so we need one more bit to encode whether it was the + or the -\n            # but because this is modular arithmetic there is no +/-, instead\n            # it can be shown that one y will always be even and the other odd.\n            prefix = b'\\x02' if self.y % 2 == 0 else b'\\x03'\n            pkb = prefix + self.x.to_bytes(32, 'big')\n        else:\n            pkb = b'\\x04' + self.x.to_bytes(32, 'big') + self.y.to_bytes(32, 'big')\n        # hash if desired\n        return ripemd160(sha256(pkb)) if hash160 else pkb\n\n    def address(self, net: str, compressed: bool) -> str:\n        \"\"\" return the associated bitcoin address for this public key as string \"\"\"\n        # encode the public key into bytes and hash to get the payload\n        pkb_hash = self.encode(compressed=compressed, hash160=True)\n        # add version byte (0x00 for Main Network, or 0x6f for Test Network)\n        version = {'main': b'\\x00', 'test': b'\\x6f'}\n        ver_pkb_hash = version[net] + pkb_hash\n        # calculate the checksum\n        checksum = sha256(sha256(ver_pkb_hash))[:4]\n        # append to form the full 25-byte binary Bitcoin Address\n        byte_address = ver_pkb_hash + checksum\n        # finally b58 encode the result\n        b58check_address = b58encode(byte_address)\n        return b58check_address\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}