{
  "hash": "db4814a9a9c53104b9a0d126c54694f4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Recap: So you want to be a Python expert?\"\ndescription: \"by James Powell, PyData Seattle 2017\"\nauthor:\n  - name: \"Tuan Le Khac\"\n    url: https://lktuan.github.io/\ncategories: [python, pydata] \ndate: 07-10-2024\ndate-modified: 07-10-2024\nimage: pydata-logo-final.png\ncode-tools: true\ncode-fold: show\ncode-annotations: hover\ndraft: false\ncss: html/styles.scss\nfig-cap-location: bottom\neditor: visual\nformat:\n  html:\n    code-overflow: wrap\n---\n\nðŸ”¥ source: [**James Powell: So you want to be a Python expert? | PyData Seattle 2017**](https://www.youtube.com/watch?v=cKPlPJyQrt4)\n\n# what is he gonna present?\n\n- something deeply behind the Zen of Python;\n- metaphors and programming in Python;\n- python is scripting language;\n- 4 features of Python and the way experts would think about these features;\n- a lot of fundamental details of how these feature work but very little talk about we can conceptualize these features in the broader sense of what they mean for modeling core problem;\n- so 4 features you might have heared before and couple of the core mental models how you can think about, an how you can think about python as a whole, wrapping everything together;\n- you will see me stumble to understand that in case you dont utd or dont have docs memorized, it's alright, the target is to know what they are and what they mean;\n- the talk presumes you to have a baseline of Python, but in case you a new to Python he believes there are cores you can take away.\n\n\n:::{layout-ncol=\"1\"}\n![James Powell on PyData Seattle 2017](James%20Powell_%20So%20you%20want%20to%20be%20a%20Python%20expert_%20_%20PyData%20Seattle%202017%205-37%20screenshot.png)\n:::\n\n# data model protocol (or dunder method)\n\nassume we have a data model with Polinomial object intitially do nothing, why I need 4 lines (instead of 2 lines) to create 2 Polynominals. How can I create and assign coefficients together.\n\n::: {#a63404a1 .cell execution_count=1}\n``` {.python .cell-code}\nclass Polynomial:\n    pass\np1= Polynomial()\np2= Polynomial()\np1.coeffs = 1, 2, 3 #  x^2 + 2x + 3\np2.coeffs = 3, 4, 3 # 3x^2 + 4x + 3\n```\n:::\n\n\nthe answer is using a constructor `__init__`, then we can compact our code like this:\n\n::: {#eacd30f8 .cell execution_count=2}\n``` {.python .cell-code}\nclass Polynomial:\n    def __init__(self, *coeffs):\n        self.coeffs = coeffs\n\np1 = Polynomial(1, 2, 3 ) #  x^2 + 2x + 3\np2 = Polynomial(3, 4, 3 ) # 3x^2 + 4x + 3\n```\n:::\n\n\nbut if we print our objects in the terminal, they look so ugly. We miss the method that actually call `repr(obj)` when we run `obj`:\n\n:::{layout-ncol=\"1\"}\n![The need of `__repr__`](1_repr.png)\n:::\n\nthat's what `__repr__` for, a printable representation of the class:\n\n::: {#559810b2 .cell execution_count=3}\n``` {.python .cell-code}\nclass Polynomial:\n    def __init__(self, *coeffs):\n        self.coeffs = coeffs\n\n    def __repr__(self):\n        return 'Polynomial(*{!r})'.format(self.coeffs)\n\n\np1 = Polynomial(1, 2, 3)  #  x^2 + 2x + 3\np2 = Polynomial(3, 4, 3)  # 3x^2 + 4x + 3\n```\n:::\n\n\nthe next thing we wanna do is to add Polinimials together `p1 + p2`.  \n\n::: {#f578a0fa .cell execution_count=4}\n``` {.python .cell-code}\n    def __add__(self, other):\n        return Polynomial(*(x + y for x, y in zip(self.coeffs, other.coeffs)))\n```\n:::\n\n\n:::{.callout-note}\nWhat is pattern here? I have some behaviours that I want to implement, and I write some **underscore** (`__x__`) funtions. We call them dunder or underscore methods.\n\nTry google \"data model\" and we'll a bunch of documents that list all method to implement the principle behaviours of our objects. There are top-level functions of top-level syntaxes that corresponding to `__`.\n\nBut there are smthg more fundamental here, when I want to:\n\n- x + y -> `__add__`;\n- initialize x -> `__init__`;\n- repr(x) -> `__repr__`.\n\nThen what if we want to implement the `len()` (return the length, which is popular know Python function) -> naturally we'll be thinking of `__len__`.\n\n::: {#9f25c761 .cell execution_count=5}\n``` {.python .cell-code}\n    def __len__(self):\n        return len(self.coeffs)\n```\n:::\n\n\n:::\n\n\nThe Python data model is a means by which you can protocols. Thos protocols have abstract meaning depending on the object itself. We tight the behaviours to top-level **syntaxes** and **functions**.\n\nSimilarly, if we do see the object Polynomial a executable, callable thing, we can implement a `__call__` which will turn our class to function, in this case we cant imagine such thing, so pass.\n\nâœ There are 3 core patterns we want to understand and remember in Python to really understand object orientation in Python:\n\n1. The protocol view of Python;\n2. The buil-in inheritance protocol;\n3. Some caveats around how OOP in Python works.\n\nWhich will be continue to present in this video is jumping into a very tricky metaphor a feature we may have heard of.\n\n# meta class\n\nimagine there are 2 groups working on some piece of software. one is core infrastructure of the group and they write `library` code, the other group is devloper group, they write `user` code. the developer use `library` code to accomplish actual business objectives. the core team less cares about business problem, they focus on technical stuffs.\n\nyou are in the dev team and there is no way to change to code of `library.py`. in what circumstance the code of `user` can break -> there is no `foo` method! To avoid that, we could simply write a test that call `bar()`, then we could know if it fails before production environment's runtime.\n\nis there anything simpler to know the ability to fail before hit run time in production env? -> use `assert` to check existence of the attribute. we will have an early warning right before the class was initiated.\n\n:::{layout-ncol=\"1\"}\n![we can know if the core team change the function name to \"food\"](2_assert.png)\n:::\n\nby this way we are enforcing constraints on the base class from the derived class.\n\nnow we move to a reverse situation, you are the core structure writer and have to deal with the meathead in the business unit that actually using/abusing/missusing your code ~ you have no idea what are they doing. you write the `Base` class with the assumption and some responsible developer in the BU will go and implement the `bar` method.\n\n:::{layout-ncol=\"1\"}\n![what if you stand on the left side pane](3_reverse_sit.png)\n:::\n\nyou have no ability to change and even have no idea where the code on the right pane sit. we can not use `hasattr()` for this particular situation. the first method is to use `try ... catch ...`, but it only catches in runtime and we will miss catching it before it goes to production env.\n\n:::{callout-note}\nThe reason that we could call Python a **protocol orientated language** is not just because the Python data model the object model is protocol orientated but that the entire Python language itself has a notion of hooks and protocols and safety valves within it.\n\nPython is much much simpler language, the code run linearly from top to bottom. And the class statement in Python is actually an executable code. We can write this:\n\n::: {#97fa423d .cell execution_count=6}\n``` {.python .cell-code}\nfor _ in range(10):\n  class Base: pass\n\n# or the same thing in other way\n\nclass Base:\n  for _ in range(10):\n    def bar(self):\n      return 'bar'\n```\n:::\n\n\nOnly the last one will survive. Python accepts this syntax because it's class is **fundamentally executable**.\n:::\n\nLet's get into something more interesting! create a class inside a function and use a function in a module in standard libbrary in Python called `dis`.\n\n::: {#d2a57c11 .cell execution_count=7}\n``` {.python .cell-code}\n# create a class inside a function\ndef _():\n  class Base:\n    pass\n\n# dis stands for disassemble\nfrom dis import dis\n```\n:::\n\n\nlet's 'dis' - stands for disassemble - to see what happen in the bytecode. there are actually things in Python bytecode call `LOAD_BUILD_CLASS`, it's actual executable runtime instruction in the Python interpreter for create a class.\n\n:::{layout-ncol=\"1\"}\n![disassemble](4_dis.png)\n:::\n\nat the first section of this lecture, we saw some **correspondence** between top-level syntac or function AND some underscore method that implements that syntax or function. there should be also top-level mechanism, not explicitly syntax or function, with the process of building a class. there is a build-ins function called `__build_class__`.\n\n::: {#595604df .cell execution_count=8}\n``` {.python .cell-code}\nold_bc = __build_class__\n\ndef my_bc(func, name, base=None, **kw):\n  if base is Base:\n    print('check if the bar method is defined')\n  if base is not None:\n    return old_bc(func, name, base, **kw)\n  return old_bc(func, name, **kw)\n\nimport builtins\nbuiltins.__build_class__ = my_bc\n```\n:::\n\n\n:::{layout-ncol=\"1\"}\n![`__build_class__`, we can check if the `bar` method is implemented, Python is **protocal oriented language**!](5_build_class.png)\n:::\n\nIt's actually quite a common pattern and quite a fundamental piece of Python almost everything that a Python language does in an execution context like building classes, creating functions, importing modules you can find a way to **hook** into that. once you can find a way to hook into that you can start doing things that you want to do like check is my user code going to break from the perspective the library author. \n\nThe most important thing here is **understanding existence of this pattern**, knowing that there are options solving such problem, and there are even better approachs.\n\n## There are 2 fundamental ways that people ussually use to solve this\n\n### 1. meta class\n\n[[futher discussion](https://stackoverflow.com/questions/395982/metaclass-new-cls-and-super-what-is-the-mechanism-exactly)]{.aside}\n\n::: {#ccdb9cd9 .cell execution_count=9}\n``` {.python .cell-code}\n# meta classes are merely derived from `type`\nclass BaseMeta(type):\n    def __new__(cls, name, bases, namespace):\n        print('BaseMeta.__new__', cls, name, bases, namespace)\n        if name != 'Base' and 'bar' not in namespace:\n            raise TypeError(\"Bad User class, 'bar' is not defined\")\n        return super().__new__(cls, name, bases, namespace)\n\n\n# then our Base should be derived from BaseMeta\nclass Base(metaclass=BaseMeta):\n    def foo(self):\n        return self.bar()\n```\n:::\n\n\n:::{layout-ncol=\"1\"}\n![metaclass](6_meta_class.png)\n:::\n\nThat's it! you can control, constraint the derived class from the base class in class hierachy.\n\n### 2. `__init_subclass__`\n\nWe can implement `Base` like this:\n\n::: {#8fdcd750 .cell execution_count=10}\n``` {.python .cell-code}\nclass Base():\n    def foo(self):\n        return self.bar()\n\n    def __init_subclass__(cls, **kwargs):\n        print(\"init subclass\", cls.__dict__, kwargs)\n        if 'bar' not in cls.__dict__:\n            raise TypeError(\"Bad sub class\")\n        super().__init_subclass__(**kwargs)\n```\n:::\n\n\n# decorator\n\nWe would have met pattern like this, that's is decorator:\n\n::: {#edfb0090 .cell execution_count=11}\n``` {.python .cell-code}\n@dec \ndef f():\n  pass\n```\n:::\n\n\nPython is a live language, there is no separate step that turns function definitions into bags of a set bits tagged and some elf binary or some [PE](https://en.wikipedia.org/wiki/Portable_Executable) binary somewhere. That a function definition is actually a live thing, it actually runs at runtime, there's actually executable code associated with this def `f()`.\n\n:::{layout-ncol=\"1\"}\n![we can interact with our object as Python is a live language, the function itself is a runtime object](7_interact_with_object.png)\n:::\n\nThat every Python structure that you interact with whether it's an object or a function or a generator has some **runtime life**, has some **runtime existence** you can see it in memory, you can ask it questions like what module UI were you defined in. you can even ask it very useful questions like if you use the inspect module you can say what's your source code.\n\n```bash\nî‚¶ decorators î‚° python -i .\\deco.py\n>>> from inspect import getsource\n>>> getsource(add)\n'def add(a, b=10):\\n    return a + b\\n'\n>>> print(getsource(add))\ndef add(a, b=10):\n    return a + b \n\n>>> \n```\n\nnow let's say I want to calculate how much time does it take to perform the `add`. simply we would thinking about `time`, like this:\n\n::: {#3bc36d3c .cell execution_count=12}\n``` {.python .cell-code}\nfrom time import time\n\ndef add(a, b=10):\n    return a + b\n \nbefore = time()\nprint('add(10)', add(10))\nafter = time()\nprint('time_taken', after - before)\nprint('add(20, 30)', add(20, 30))\nafter = time()\nprint('time_taken', after - before)\nprint('add(\"a\", \"b\")', add(\"a\", \"b\"))\nafter = time()\nprint('time_taken', after - before)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadd(10) 20\ntime_taken 0.0\nadd(20, 30) 50\ntime_taken 0.0\nadd(\"a\", \"b\") ab\ntime_taken 0.0\n```\n:::\n:::\n\n\nthere is something wrong here because we need to add code to everywhere we want to calculate. we see another important pattern in Python, decorator, the Python developers want you to write the simplest, stupidest, quickest thing to get the job done and get the rest of your day with your family.\n\nwe will see alot of scenarios where of cases where you can write the simple and stupidest thing to get the job done and when the task at hand becomes harder or more complex or the requirements change you can change your code in a very simple fashion to linearly extend its functionality without have to re-write it from scratch.\n\nin Python we'll see a number of different features are orientated around how do we write the simplest thing today and then when the problem gets a little bit harder we have an avenue for making our code a little bit more complex.\n\nwe can modified a `add` alittle bit\n\n::: {#2f6e6ca5 .cell execution_count=13}\n``` {.python .cell-code}\nfrom time import time\n\ndef add(a, b=10):\n    before = time()\n    rv = a + b\n    after = time()\n    print('elapsed:', after - before)\n    return rv\n```\n:::\n\n\nBut if we have more functions, let say `sub`? We need to modify and make our code complicated. **Python is live language** that everything has some runtime representaion. We can create `timer()` which take `func`, `x`, and `y` as arguments (`x` and `y` will be forwarded to calculation function)\n\n::: {#d3e6dcb7 .cell execution_count=14}\n``` {.python .cell-code}\nfrom time import time\n\ndef timer(func, x, y):\n    before = time()\n    rv = func(x,y)\n    after = time()\n    print('elapsed:', after - before)\n    return rv\n\n# and \nprint('add(20, 30)', timer(add, 20, 30))\n```\n:::\n\n\nwe can also wrapping like this, `timer()` will return a function `f`:\n\n::: {#2ff12e9a .cell execution_count=15}\n``` {.python .cell-code}\nfrom time import time\n\ndef timer(func):\n    def f(x, y=10):\n      before = time()\n      rv = func(x,y)\n      after = time()\n      print('elapsed:', after - before)\n      return rv\n    return f\n\n# and \nadd = timer(add)\nprint('add(20, 30)', add(20, 30))\n```\n:::\n\n\nPython provides a syntax for easily implement every behaviours of `timer()` to every function:\n\n::: {#cbed9524 .cell execution_count=16}\n``` {.python .cell-code}\n@timer\ndef add(a, b=10):\n    return a + b\n\nprint('add(20, 30)', add(20, 30))\n```\n:::\n\n\n:::{.callout-note}\nFundamentally it's about allowing you to take this wrapping behavior for functions and to wrap wide swathes of functions in one fashion without having to rewrite a lot of user code or having to even perform a lot of turn on your library code.\n:::\n\nanother example when we want a function to run n-times:\n\n::: {#25fcf462 .cell execution_count=17}\n``` {.python .cell-code}\nn = 2 # let's say 2 times\n\ndef ntimes(f):\n  def wrapper(*args, **kwargs):\n    for _ in range(n):\n      print('running {.__name__}'.format(f))\n      rv = f(*args, **kwargs)\n    return rv\n  return wrapper\n    \n@ntimes\ndef add(a, b=10):\n    return a + b\n\nadd(10, 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrunning add\nrunning add\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n30\n```\n:::\n:::\n\n\nwrapp `n` in to the function so `ntimes()` takes `n` instead of `f` as arg:\n\n::: {#e09e7e75 .cell execution_count=18}\n``` {.python .cell-code}\n# high order decorators\ndef ntimes(n):\n  def inner(f):\n    def wrapper(*args, **kwargs):\n      for _ in range(n):\n        print('running {.__name__}'.format(f))\n        rv = f(*args, **kwargs)\n      return rv\n    return wrapper\n  return inner\n    \n@ntimes(3)\ndef add(a, b=10):\n    return a + b\n\nadd(10, 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrunning add\nrunning add\nrunning add\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n30\n```\n:::\n:::\n\n\nThere is a very important core concept that is hidden in here which is what you might call the **closure object duality**. it's not something that we have time to look at in this session.\n\n\n\n# generator\n\n# context manager\n\n# summary\n\n# futher reading\n\n1. [Python data model](https://docs.python.org/3/reference/datamodel.html)\n2. [Python metaclass `__new__`](https://www.geeksforgeeks.org/python-metaclass-__new__-method/)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}