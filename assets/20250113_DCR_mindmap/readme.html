<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="This is Tuan’s blog">

<title>readme – Le Khac Tuan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/rocket_1613268.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-8e54dfbe729680b42f22c627ac27a053.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-81b089a3b74ed4cf194f083418e7130b.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-981c06c6822917ee50b1e3607856c995.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5525a9a0cc1049c3aa706be4fdbcc2dc.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Le Khac Tuan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about/index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../curriculum/index.html"> 
<span class="menu-text">Curriculum</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../学汉语的日记.html"> 
<span class="menu-text">学汉语的日记</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../jiu_jitsu_journal/index.html"> 
<span class="menu-text">Jiu Jitsu Journal</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/lktuan"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/tuanlekhac/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.facebook.com/toilatuan.lk/"> <i class="bi bi-facebook" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/Halle4231"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/@tuan_lekhac"> <i class="bi bi-youtube" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:tuan.lekhac0905@gmail.com"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="deep-credit-risk-machine-learning-with-python---a-comprehensive-summary" class="level1">
<h1>Deep Credit Risk: Machine Learning with Python - A Comprehensive Summary</h1>
<p>This document provides a detailed summary of the book “Deep Credit Risk: Machine Learning with Python,” covering key concepts, formulas, and practical implementations. It aims to serve as a comprehensive guide for credit risk analysts and practitioners.</p>
<section id="part-i-principles-of-data-learning" class="level2">
<h2 class="anchored" data-anchor-id="part-i-principles-of-data-learning">Part I: Principles of Data Learning</h2>
<section id="deep-dive" class="level3">
<h3 class="anchored" data-anchor-id="deep-dive">1. Deep Dive</h3>
<p>This section introduces the practical aspects of machine learning in credit risk, emphasizing the importance of hands-on experience and real-world data.</p>
<p><strong>Key Objectives in Credit Risk Analysis using Machine Learning:</strong></p>
<ul>
<li><strong>Feature Understanding:</strong> Comprehending the role of various financial features, including liquidity, equity, macroeconomic indicators, and borrower characteristics.</li>
<li><strong>Prediction:</strong> Building models to predict key credit risk outcomes:
<ul>
<li><strong>Defaults:</strong> Probability of Default (PD).</li>
<li><strong>Payoffs:</strong> Probability of Prepayment (PP).</li>
<li><strong>Loss Rates:</strong> Loss Given Default (LGD).</li>
<li><strong>Exposures:</strong> Exposure at Default (EAD).</li>
</ul></li>
<li><strong>Downturn and Crisis Prediction:</strong> Developing models to predict downturn and crisis outcomes using pre-crisis data. This is particularly relevant for stress testing and capital planning.</li>
<li><strong>Model Interpretation and Validation:</strong> Understanding model behavior, limitations, and validating results using appropriate techniques.</li>
</ul>
<p><strong>Credit Risk Information:</strong> Commercial banks categorize data based on the stage of the lending process. Understanding the source and nature of these datasets is crucial for feature engineering and model building:</p>
<ul>
<li><strong>Origination/Underwriting Data:</strong> Data collected during loan application and approval, including borrower demographics, credit history, loan terms, and collateral information.</li>
<li><strong>Performance Data:</strong> Ongoing loan performance data collected typically at monthly, quarterly, or annual intervals. This data includes payment history, outstanding balances, and delinquencies.</li>
<li><strong>Modification Data:</strong> Data related to loan modifications, such as changes in interest rates, loan terms, or payment schedules.</li>
<li><strong>Payoff/Retention Data:</strong> Loan payoff information, including full prepayments, partial prepayments, and loan refinancing details.</li>
<li><strong>Maturity Data:</strong> Data related to loan maturity, often including administrative matters such as release of collateral and accounting activities.</li>
<li><strong>Default/Workout Data:</strong> Data collected during the default and resolution processes. This includes recovery cash flows, workout expenses, and the time taken for resolution.</li>
</ul>
<p><strong>External Data:</strong> Supplementing internal bank data with external sources can significantly improve model accuracy and capture broader economic trends:</p>
<ul>
<li><strong>Macroeconomic Information:</strong> Time-varying economic data, such as GDP growth rates, unemployment rates, inflation, interest rates, and housing market indices. These factors can significantly influence borrower behavior and default rates.</li>
<li><strong>Population Statistics:</strong> Demographic data, such as population growth, age distribution, income levels, and geographic location.</li>
<li><strong>Other Data Sources:</strong> A wide range of alternative data sources can be incorporated, including:
<ul>
<li><strong>Business Filings:</strong> Information on company performance and financial health.</li>
<li><strong>Social Media Data:</strong> Sentiment analysis and online behavior can provide insights into borrower characteristics.</li>
<li><strong>Expert Ratings:</strong> Credit ratings from agencies like Moody’s, S&amp;P, and Fitch.</li>
<li><strong>Property Appraisals:</strong> Information on collateral value.</li>
<li><strong>Geolocation Data:</strong> Information on property location and neighborhood characteristics.</li>
</ul></li>
</ul>
<p><strong>Loan-to-Value Ratio (LTV):</strong> A critical metric in mortgage lending, representing the ratio of the loan amount to the appraised value of the property:</p>
<ul>
<li><strong>LTV_time:</strong> LTV at the observation time, reflecting changes in both loan balance and property value.</li>
<li><strong>LTV_orig_time:</strong> LTV at the origination time, representing the initial risk assessment at loan inception.</li>
</ul>
<p><strong>LTV Calculation:</strong></p>
<pre><code>LTV_time = balance_time / house_price_at_time
house_price_at_time = house_price_at_origination * (hpi_time / hpi_orig_time)
house_price_at_origination = balance_orig_time / LTV_orig_time</code></pre>
<p>where:</p>
<ul>
<li><code>balance_time</code>: Outstanding loan balance at observation time.</li>
<li><code>house_price_at_time</code>: Estimated house price at observation time.</li>
<li><code>house_price_at_origination</code>: Estimated house price at loan origination.</li>
<li><code>hpi_time</code>: House price index at observation time.</li>
<li><code>hpi_orig_time</code>: House price index at loan origination.</li>
<li><code>balance_orig_time</code>: Original loan balance.</li>
<li><code>LTV_orig_time</code>: LTV ratio at origination.</li>
</ul>
</section>
<section id="python-literacy" class="level3">
<h3 class="anchored" data-anchor-id="python-literacy">2. Python Literacy</h3>
<p>This chapter focuses on equipping readers with the necessary Python skills for credit risk analysis.</p>
<p><strong>Key Packages:</strong></p>
<ul>
<li><strong>pandas:</strong> Data structures (Series, DataFrames), data manipulation, analysis, and cleaning. Essential for working with tabular data, handling missing values, and performing data transformations.</li>
<li><strong>numpy:</strong> N-dimensional arrays, mathematical functions, linear algebra, and random number generation. Provides the foundation for numerical computations in Python.</li>
<li><strong>scipy:</strong> Statistical functions, optimization algorithms, signal processing, and more. Extends the capabilities of <code>numpy</code> with advanced scientific computing tools.</li>
<li><strong>matplotlib:</strong> Plotting and visualization library. Creating static, interactive, and animated visualizations in Python. Crucial for exploratory data analysis and communicating results.</li>
<li><strong>scikit-learn:</strong> Machine learning algorithms, model selection, evaluation, and preprocessing. A comprehensive library for building and evaluating machine learning models.</li>
<li><strong>statsmodels:</strong> Statistical modeling, hypothesis testing, and econometrics. Offers a wider range of statistical models and tools compared to <code>scikit-learn</code>.</li>
</ul>
<p><strong>Data Subsetting and Manipulation:</strong> <code>pandas</code> provides powerful tools for slicing, dicing, and manipulating DataFrames:</p>
<ul>
<li><code>.loc[]</code>: Label-based indexing. Accessing rows and columns by their labels (e.g., column names).</li>
<li><code>.iloc[]</code>: Integer-based indexing. Accessing rows and columns by their integer positions.</li>
<li><code>.query()</code>: Filtering based on conditions. A convenient way to select rows based on Boolean expressions.</li>
<li><code>.sample()</code>: Random sampling. Drawing random samples from a DataFrame, useful for creating training and testing sets.</li>
<li><code>.drop()</code>: Dropping rows or columns. Removing unwanted data from a DataFrame.</li>
<li><code>.groupby()</code>: Grouping data based on values in one or more columns. Essential for summarizing and aggregating data.</li>
<li><code>.sort_values()</code>: Sorting data by one or more columns.</li>
<li><code>.fillna()</code>: Filling missing values.</li>
<li><code>.replace()</code>: Replacing specific values.</li>
<li><code>.apply()</code>: Applying a function to each element, row, or column.</li>
<li><code>.transform()</code>: Transforming data within groups.</li>
<li><code>.astype()</code>: Converting data types.</li>
<li><code>.clip()</code>: Capping and flooring values (winsorizing).</li>
</ul>
<p><strong>Data Combining:</strong> Combining data from multiple sources is often necessary in credit risk analysis:</p>
<ul>
<li><code>.concat()</code>: Concatenating DataFrames. Combining DataFrames along rows or columns.</li>
<li><code>.append()</code>: Appending rows. Adding rows from one DataFrame to another.</li>
<li><code>.merge()</code>: Joining DataFrames based on columns. Similar to SQL joins, allowing for flexible data integration.</li>
<li><code>.join()</code>: Joining DataFrames based on indices. Combining DataFrames based on their index values.</li>
</ul>
<p><strong>Regression Models:</strong></p>
<p>Basic example of fitting a linear regression using <code>statsmodels</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>data_ols <span class="op">=</span> smf.ols(formula<span class="op">=</span><span class="st">'LTV_time ~ LTV_orig_time + gdp_time'</span>, data<span class="op">=</span>data).fit()</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data_ols.summary())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This code snippet demonstrates how to use the <code>ols</code> function from <code>statsmodels.formula.api</code> to fit a linear regression model. The <code>formula</code> argument specifies the model equation, and the <code>data</code> argument specifies the DataFrame containing the data. The <code>.fit()</code> method estimates the model parameters, and the <code>summary()</code> method prints a summary of the results.</p>
<p><strong>numpy vs pandas:</strong></p>
<ul>
<li><code>numpy</code>: Focuses on numerical computation with arrays. Efficient for numerical operations and mathematical calculations.</li>
<li><code>pandas</code>: Provides enhanced data structures (DataFrames) with label-based indexing and extensive functionalities for data analysis and manipulation. More suitable for data cleaning, transformation, and exploration.</li>
</ul>
<p><strong>Module <code>dcr</code>:</strong> The book introduces a custom Python module <code>dcr.py</code> which contains several credit risk-specific functions. These functions provide convenient tools for performing common credit risk analysis tasks, such as data preparation, feature engineering, model validation, and handling resolution bias (detailed later).</p>
</section>
<section id="risk-based-learning" class="level3">
<h3 class="anchored" data-anchor-id="risk-based-learning">3. Risk-Based Learning</h3>
<p>This chapter delves into statistical learning techniques commonly used in credit risk, focusing on Maximum Likelihood Estimation (MLE) and Bayesian methods.</p>
<p><strong>Maximum-Likelihood Estimation (MLE):</strong> A method for estimating model parameters by finding the parameter values that maximize the likelihood function. The likelihood function represents the probability of observing the data given the model and its parameters.</p>
<p><strong>Example for Default Modeling (Binomial MLE):</strong> Consider a simple case of estimating the probability of default (PD) π from a sample of n independent loans, where d loans default. The likelihood function is:</p>
<pre><code>L(π) = (n choose d) * π^d * (1 - π)^(n-d)</code></pre>
<p>The MLE for π is the sample default rate:</p>
<pre><code>π = d / n</code></pre>
<p><strong>MLE for Logistic Regression:</strong> In logistic regression, the likelihood function is more complex, as the PD is modeled as a function of features. The likelihood function for n observations is:</p>
<pre><code>L(β) = Π [πi^di * (1 - πi)^(1-di)]</code></pre>
<p>where:</p>
<ul>
<li>πi = 1 / (1 + exp(-β’xi)) is the predicted PD for loan i.</li>
<li>β is the vector of model parameters.</li>
<li>xi is the vector of features for loan i.</li>
<li>di is the default indicator for loan i (1 if default, 0 otherwise).</li>
</ul>
<p>The MLE for β is typically found using numerical optimization algorithms, as there is no closed-form solution.</p>
<p><strong>Bayesian Approaches:</strong> In Bayesian learning, model parameters are treated as random variables with prior distributions. These prior distributions represent our initial beliefs about the parameters before observing any data. The observed data is then used to update the prior distribution via Bayes’ theorem, resulting in the posterior distribution. The posterior distribution represents our updated beliefs about the parameters after observing the data.</p>
<p><strong>Bayes’ Theorem:</strong></p>
<pre><code>P(θ|D) = [P(D|θ) * P(θ)] / P(D)</code></pre>
<p>where:</p>
<ul>
<li>θ represents the model parameters.</li>
<li>D represents the observed data.</li>
<li>P(θ|D) is the posterior distribution of the parameters given the data.</li>
<li>P(D|θ) is the likelihood function (probability of observing the data given the parameters).</li>
<li>P(θ) is the prior distribution of the parameters.</li>
<li>P(D) is the marginal likelihood (probability of observing the data, regardless of the parameter values).</li>
</ul>
<p><strong>Markov-Chain Monte Carlo (MCMC):</strong> A simulation technique used to approximate posterior distributions in Bayesian learning, particularly when the posterior is complex and cannot be calculated analytically. MCMC methods generate a sequence of random samples from the posterior distribution, which can be used to estimate various properties of the posterior, such as the mean, variance, and credible intervals.</p>
</section>
<section id="machine-learning" class="level3">
<h3 class="anchored" data-anchor-id="machine-learning">4. Machine Learning</h3>
<p>This chapter provides a foundation for understanding key machine learning concepts, terminology, cost functions, and optimization techniques.</p>
<p><strong>Terminology:</strong> Machine learning uses slightly different terminology compared to traditional statistics. Understanding these terms is important for following the discussions in the book.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Risk-Based Learning</th>
<th>Machine Learning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Estimation</td>
<td>Fitting</td>
</tr>
<tr class="even">
<td>Independent/Explanatory Variable (X)</td>
<td>Input, Feature</td>
</tr>
<tr class="odd">
<td>Dependent/Response Variable (Y)</td>
<td>Output</td>
</tr>
<tr class="even">
<td>Random Error</td>
<td>Noise</td>
</tr>
<tr class="odd">
<td>In-Sample</td>
<td>Training Set</td>
</tr>
<tr class="even">
<td>Out-of-Sample</td>
<td>Test Set</td>
</tr>
<tr class="odd">
<td>Estimate a Model</td>
<td>Learn a Model</td>
</tr>
<tr class="even">
<td>Model Parameters</td>
<td>Model Weights</td>
</tr>
<tr class="odd">
<td>Regression, Classification</td>
<td>Supervised Learning</td>
</tr>
<tr class="even">
<td>Clustering, Dimensionality Reduction</td>
<td>Unsupervised Learning</td>
</tr>
<tr class="odd">
<td>Data Point, Observation</td>
<td>Instance, Sample</td>
</tr>
<tr class="even">
<td>Intercept</td>
<td>Bias</td>
</tr>
<tr class="odd">
<td>Link Function</td>
<td>Activation Function</td>
</tr>
<tr class="even">
<td>Logistic</td>
<td>Sigmoid</td>
</tr>
</tbody>
</table>
<p><strong>Cost/Loss Functions:</strong> Functions that measure the difference between predicted and observed values. The goal of machine learning is to find model parameters that minimize the cost function.</p>
<ul>
<li><strong>Mean Squared Error (MSE):</strong> A common loss function for regression problems, measuring the average squared difference between predicted and observed values.</li>
</ul>
<pre><code>MSE = (1/n) * Σ(yi - ŷi)^2</code></pre>
<ul>
<li><strong>Binary Cross-Entropy:</strong> A common loss function for binary classification problems, measuring the average cross-entropy between the predicted probabilities and the observed binary outcomes. It is closely related to the negative log-likelihood in logistic regression.</li>
</ul>
<pre><code>Binary Cross-Entropy = - (1/n) * Σ [yi*log(πi) + (1 - yi)*log(1 - πi)]</code></pre>
<ul>
<li><strong>Categorical Cross-Entropy:</strong> A generalization of binary cross-entropy for multi-class classification problems.</li>
</ul>
<p><strong>Information Theory (for Categorical Outputs):</strong> Information theory provides useful concepts for understanding the information content of variables and events, particularly in classification problems.</p>
<ul>
<li><strong>Information:</strong> Measures the amount of surprise associated with an event. For a default event with probability π, the information is:</li>
</ul>
<pre><code>I(d) = -log2(π)</code></pre>
<ul>
<li><strong>Entropy:</strong> Measures the average information content of a random variable. For a binary variable (default/non-default) with probability of default π, the entropy is:</li>
</ul>
<pre><code>H = -πln(π) – (1 – π)ln(1 – π)</code></pre>
<ul>
<li><strong>Cross-Entropy:</strong> Measures the average information content when using a predicted probability distribution q to represent a true probability distribution p.&nbsp;For binary classification, the cross-entropy between the predicted PD π and the observed default d is:</li>
</ul>
<pre><code>H* = -dln(π) – (1 – d)ln(1 – π)</code></pre>
<p><strong>Optimization: Gradient Descent:</strong> An iterative optimization algorithm for finding the minimum of a function. Gradient descent works by repeatedly updating the model parameters in the direction of the negative gradient of the cost function.</p>
<p><strong>Gradient Descent Update Rule:</strong></p>
<pre><code>θk+1 = θk - η * ∇J(θk)</code></pre>
<p>where:</p>
<ul>
<li>θk is the vector of model parameters at iteration k.</li>
<li>η is the learning rate (controlling the step size).</li>
<li>∇J(θk) is the gradient of the cost function J at θk.</li>
</ul>
<p><strong>Variants of Gradient Descent:</strong></p>
<ul>
<li><strong>Stochastic Gradient Descent (SGD):</strong> Updates parameters based on the gradient computed from a single observation (or a small batch of observations).</li>
<li><strong>Mini-Batch Gradient Descent:</strong> Updates parameters based on the gradient computed from a small batch of observations.</li>
<li><strong>Batch Gradient Descent:</strong> Updates parameters based on the gradient computed from the entire training dataset.</li>
<li><strong>Adaptive Gradient Descent Algorithms (e.g., Adam, RMSprop):</strong> Adapt the learning rate for each parameter based on past gradients.</li>
</ul>
<p><strong>Learning and Validation:</strong></p>
<ul>
<li><strong>Train-Test Split:</strong> Dividing the data into training and testing sets is crucial for evaluating model performance on unseen data. The training set is used to train the model, and the test set is used to evaluate the model’s performance on data it has not seen before. This helps to assess the model’s ability to generalize to new data.</li>
<li><strong>Bias-Variance Tradeoff:</strong> The bias-variance tradeoff is a fundamental concept in machine learning. Bias refers to the error introduced by approximating a real-world problem, which may be complex, by a simplified model. Variance refers to the model’s sensitivity to fluctuations in the training data. A model with high bias will underfit the data (i.e., fail to capture the underlying patterns), while a model with high variance will overfit the data (i.e., capture noise in the training data). The goal is to find a model with low bias and low variance.</li>
<li><strong>Cross-Validation:</strong> A technique for evaluating model performance and tuning hyperparameters. In k-fold cross-validation, the training data is divided into k folds. The model is trained on k-1 folds and evaluated on the remaining fold. This process is repeated k times, with each fold serving as the validation set once. The average performance across the k folds is then used as an estimate of the model’s performance. This technique helps to reduce the variance in the performance estimate compared to a single train-test split.</li>
<li><strong>Overfitting:</strong> Occurs when a model learns the training data too well, capturing noise and idiosyncrasies that are not representative of the underlying data generating process. An overfitted model will perform well on the training data but poorly on unseen data.</li>
<li><strong>Underfitting:</strong> Occurs when a model is too simple to capture the underlying patterns in the data. An underfitted model will perform poorly on both training and unseen data.</li>
<li><strong>Regularization:</strong> A technique for preventing overfitting by adding a penalty term to the cost function. The penalty term discourages the model from learning overly complex relationships in the training data. Common regularization techniques include L1 (LASSO), L2 (Ridge), and Elastic Net regularization.</li>
<li><strong>Hyperparameter Tuning:</strong> Many machine learning models have hyperparameters that control the model’s complexity and learning behavior. Hyperparameter tuning involves finding the optimal hyperparameter values that minimize the model’s error on a validation set. Common techniques for hyperparameter tuning include grid search, random search, and Bayesian optimization.</li>
</ul>
</section>
</section>
<section id="part-ii-data-processing-and-validation-continued" class="level2">
<h2 class="anchored" data-anchor-id="part-ii-data-processing-and-validation-continued">Part II: Data Processing and Validation (Continued)</h2>
<section id="outcome-engineering-continued" class="level3">
<h3 class="anchored" data-anchor-id="outcome-engineering-continued">5. Outcome Engineering (Continued)</h3>
<p><strong>Outcomes in Credit Risk:</strong></p>
<ul>
<li><strong>Survival (0):</strong> The loan continues to the next period without default or payoff. This is the most common outcome in most credit portfolios.</li>
<li><strong>Default (1):</strong> The borrower fails to meet payment obligations, typically defined by a certain number of days past due (e.g., 90 days). Default is a key event in credit risk, leading to potential losses for the lender.</li>
<li><strong>Payoff (2):</strong> The borrower fully repays the loan before its scheduled maturity. This can occur through full prepayment, refinancing, or loan sale.</li>
<li><strong>Maturity (3):</strong> The loan reaches its scheduled maturity date, and the remaining balance is fully repaid.</li>
</ul>
<p><strong>Cure:</strong> A cure event occurs when a defaulted loan returns to performing status, i.e., the borrower resumes making regular payments.</p>
<p><strong>Loss Given Default (LGD):</strong> The percentage of the outstanding loan amount that is lost in the event of default, net of recovery proceeds. LGD is a crucial parameter in credit risk modeling, representing the severity of losses.</p>
<p><strong>LGD Calculation:</strong></p>
<pre><code>LGD = (EAD - Σ(CFt / (1 + rt)^t)) / EAD</code></pre>
<p>where:</p>
<ul>
<li><code>EAD</code>: Exposure at Default (outstanding loan balance at the time of default).</li>
<li><code>CFt</code>: Workout cash flows received at time t after default.</li>
<li><code>rt</code>: Discount rate applied to the workout cash flows at time t.</li>
<li><code>t</code>: Time period after default.</li>
</ul>
<p><strong>Recovery Rate (RR):</strong> The complement of LGD, representing the percentage of the outstanding loan amount that is recovered in the event of default.</p>
<pre><code>RR = 1 - LGD</code></pre>
<p><strong>Exposure Conversion Measures:</strong> These measures are used to standardize loan exposures, accounting for differences in loan sizes and characteristics. This is particularly important when modeling portfolio credit risk, as it allows for comparisons across different loans and portfolios.</p>
<ul>
<li><strong>Exposure at Default (EAD):</strong> The outstanding loan amount at the time of default.</li>
<li><strong>Credit Conversion Factor (CCF):</strong> The ratio of the change in exposure to the unused portion of a credit line. Used primarily for credit lines and revolving credit facilities.</li>
<li><strong>Credit Equivalent Amount (CEA):</strong> EAD adjusted for credit risk mitigation techniques (e.g., collateral).</li>
<li><strong>Commitment Amount:</strong> The maximum amount that a lender has committed to lend to a borrower.</li>
</ul>
<p><strong>Default Engineering:</strong> The process of creating and transforming default-related variables for use in credit risk models.</p>
<ul>
<li><strong>Time-Vintage-Age (TVA) Analysis:</strong> Analyzing default rates by time, vintage (loan origination time), and age (time since origination). This helps to understand how default rates evolve over time and identify potential vintage effects (i.e., differences in default rates across loans originated at different times).</li>
<li><strong>Multi-Lead Analysis:</strong> Predicting default over different future time horizons (e.g., 1-year, 2-year). This is important for forecasting losses and assessing the risk profile of a loan over time.</li>
<li><strong>Multi-Period Analysis:</strong> Analyzing cumulative and marginal default rates over multiple periods, often up to the lifetime of a loan. This is essential for IFRS 9 and CECL calculations.</li>
</ul>
<p><strong>Cumulative Default Rate:</strong> The probability that a loan will default within a given time horizon, conditional on surviving up to that point.</p>
<p><strong>Marginal Default Rate:</strong> The probability that a loan will default in a given period, conditional on surviving up to the beginning of that period.</p>
<p><strong>LGD Engineering:</strong> The process of creating and transforming LGD-related variables for use in credit risk models.</p>
<ul>
<li><strong>Resolution Period:</strong> The time elapsed between the default event and the resolution of the loan, typically when all recovery cash flows have been collected. The resolution period can vary significantly across loans and can have a significant impact on LGD.</li>
<li><strong>LGD Discount Rates:</strong> The discount rate used to discount future recovery cash flows to the present value. The choice of discount rate can have a substantial impact on LGD estimates. Common choices include the loan contract rate, the risk-free rate, and the bank’s cost of funds.</li>
<li><strong>Resolution Bias:</strong> A bias in observed LGDs that arises due to the fact that loans with longer resolution periods tend to have higher LGDs. This is because more losses are typically realized as the resolution period increases. Addressing resolution bias is crucial for accurate LGD modeling. Techniques for addressing resolution bias include excluding loans with incomplete workouts, imputing missing LGD values, and using survival models.</li>
</ul>
</section>
<section id="feature-engineering-continued" class="level3">
<h3 class="anchored" data-anchor-id="feature-engineering-continued">6. Feature Engineering (Continued)</h3>
<p><strong>Missing Feature Analysis:</strong> Handling missing values in features is a crucial step in data preparation. Different approaches can be taken depending on the nature and extent of missingness.</p>
<ul>
<li><strong>Keeping Missing Values:</strong> If the missingness itself is informative (e.g., missing credit score might indicate a higher risk borrower), creating a separate category or indicator for missing values can be beneficial.</li>
<li><strong>Deleting Missing Values (Listwise Deletion):</strong> Removing observations with missing values on any of the features. This approach is simple but can lead to substantial data loss and potential bias if the missingness is not random.</li>
<li><strong>Imputation:</strong> Replacing missing values with estimated values. Common imputation methods include:
<ul>
<li><strong>Mean/Median/Mode Imputation:</strong> Replacing missing values with the mean, median, or mode of the non-missing values for that feature.</li>
<li><strong>Regression Imputation:</strong> Predicting missing values using a regression model based on other features.</li>
<li><strong>K-Nearest Neighbors Imputation:</strong> Imputing missing values based on the values of the k-nearest neighbors in the feature space.</li>
<li><strong>Multiple Imputation:</strong> Creating multiple imputed datasets and combining the results.</li>
</ul></li>
</ul>
<p><strong>Feature Outlier Analysis:</strong> Outliers are extreme values that can distort model estimates and predictions. Different methods can be used to identify and handle outliers:</p>
<ul>
<li><strong>Keeping Outliers:</strong> In some cases, outliers might represent genuine extreme values and should be retained in the data.</li>
<li><strong>Deleting Outliers:</strong> Removing outliers from the dataset. This is a simple approach but can lead to information loss.</li>
<li><strong>Winsorizing:</strong> Capping and flooring values at certain percles (e.g., 1st and 99th percentiles). This preserves the information contained in the extreme values while reducing their influence on model estimates.</li>
<li><strong>Trimming:</strong> Removing a fixed percentage of the most extreme values from both tails of the distribution.</li>
<li><strong>Transformation:</strong> Applying a non-linear transformation (e.g., log transformation) to reduce the impact of outliers.</li>
</ul>
<p><strong>Scaling:</strong> Scaling involves transforming feature values to a specific range. This is often necessary to improve model performance, particularly for distance-based algorithms like K-Nearest Neighbors and Support Vector Machines.</p>
<ul>
<li><strong>Feature Ratios:</strong> Creating new features by dividing one feature by another. This can be helpful for capturing relationships between features and reducing the influence of scale. Examples include debt-to-income ratio, loan-to-value ratio, and current ratio.</li>
<li><strong>Decimal Scaling:</strong> Multiplying or dividing a feature by a constant factor (e.g., 10, 100, 1000). This simply shifts the decimal point and can be useful for features with large values.</li>
<li><strong>Min-Max Scaling:</strong> Scaling features to a specific range (e.g., [0, 1]). This is done by subtracting the minimum value and dividing by the range (maximum - minimum).</li>
</ul>
<pre><code>x_scaled = (x - min(x)) / (max(x) - min(x))</code></pre>
<ul>
<li><strong>Standardization (Z-score Normalization):</strong> Subtracting the mean and dividing by the standard deviation. This transforms the feature to have a mean of 0 and a standard deviation of 1.</li>
</ul>
<pre><code>x_scaled = (x - mean(x)) / std(x)</code></pre>
<ul>
<li><strong>Normalization (Unit Vector Normalization):</strong> Scaling features to have a unit norm (Euclidean norm of 1). This is typically done by dividing each feature vector by its norm.</li>
</ul>
<p><strong>Non-linear Feature Transformations:</strong> These transformations are used to capture non-linear relationships between features and the outcome variable.</p>
<ul>
<li><strong>Polynomials:</strong> Adding polynomial terms (e.g., x^2, x^3) to the model. This allows the model to capture curved relationships between features and the outcome.</li>
<li><strong>Splines:</strong> Piecewise polynomial functions that can model complex non-linear relationships. Splines are defined by a set of knots (breakpoints) and polynomial segments between the knots.</li>
<li><strong>Categorization (Binning, Discretization):</strong> Converting continuous variables into categorical variables by dividing the value range into bins or intervals. This can be useful for capturing non-linear relationships and for handling outliers.</li>
<li><strong>Weight-of-Evidence (WOE):</strong> A technique for transforming categorical variables based on the log-odds ratio. WOE is often used in credit scoring and can improve model performance by capturing the predictive power of categorical features. For a category k, the WOE is calculated as:</li>
</ul>
<pre><code>WOEk = ln(%defaultsk / %nondefaultsk)</code></pre>
<p><strong>Feature Reduction:</strong> Techniques for reducing the number of features in the dataset while preserving relevant information.</p>
<ul>
<li><strong>Aggregation:</strong> Combining multiple features into a single composite score (e.g., credit score). This can simplify the model and improve interpretability.</li>
<li><strong>Clustering:</strong> Grouping similar observations based on their feature values. The cluster assignments can then be used as a new feature in the model.</li>
<li><strong>Principal Component Analysis (PCA):</strong> A linear dimensionality reduction technique that creates a set of uncorrelated principal components from the original features. The principal components are ordered by the amount of variance they explain, and the first few principal components often capture most of the information contained in the original features. PCA can reduce model complexity and improve performance by removing redundant information.</li>
</ul>
</section>
<section id="feature-selection-continued" class="level3">
<h3 class="anchored" data-anchor-id="feature-selection-continued">7. Feature Selection (Continued)</h3>
<p><strong>Economic Feature Selection:</strong> Selecting features based on economic theory, domain expertise, and business intuition. This involves understanding the underlying economic drivers of credit risk and selecting features that are expected to be relevant for predicting default or other credit risk outcomes. Examples include:</p>
<ul>
<li><strong>Borrower Features:</strong> Income, wealth, debt levels, employment history, and credit score.</li>
<li><strong>Loan Features:</strong> Loan amount, interest rate, loan term, and loan type.</li>
<li><strong>Macroeconomic Features:</strong> GDP growth rate, unemployment rate, and interest rates.</li>
</ul>
<p><strong>Univariate Feature Selection:</strong> Evaluating each feature individually based on its statistical relationship with the outcome variable. These methods are computationally efficient but may not capture interactions between features.</p>
<ul>
<li><strong>Means Test (t-test):</strong> Comparing the means of a feature for different outcome groups (e.g., default vs.&nbsp;non-default). A significant difference in means suggests that the feature is related to the outcome.</li>
<li><strong>F-Statistic (ANOVA):</strong> Testing for differences in variance between outcome groups. Similar to the t-test, but focuses on variance instead of means.</li>
<li><strong>Association (Correlation):</strong> Measuring the linear relationship between a feature and the outcome. The correlation coefficient measures the strength and direction of the linear relationship.</li>
<li><strong>WOE and Information Value (IV):</strong> The information value (IV) measures the predictive power of a categorical feature. It is calculated based on the WOE values for each category. A higher IV indicates a stronger relationship between the feature and the outcome.</li>
</ul>
<p><strong>Information Value Calculation:</strong></p>
<pre><code>IV = Σ [( %defaultsk - %nondefaultsk) * WOEk ]</code></pre>
<p><strong>Model-based Feature Selection:</strong> These methods use a model to assess feature importance. They can capture interactions between features and are generally more powerful than univariate methods, but can also be computationally more expensive.</p>
<ul>
<li><strong>Manual Selection:</strong> Trying different feature combinations and evaluating model performance on a validation set. This approach is simple but can be time-consuming and may not find the optimal feature subset.</li>
<li><strong>In (1) and Out (0) Selection (Feature Importance):</strong> Training a model (e.g., logistic regression) and selecting features based on their coefficients or other measures of importance (e.g., feature importance scores from tree-based models).</li>
<li><strong>Recursive Feature Elimination (RFE):</strong> Recursively removing features based on their importance in a model. RFE starts with all features and iteratively removes the least important feature until the desired number of features is reached.</li>
<li><strong>Regularization (L1, L2, Elastic Net):</strong> Adding a penalty term to the cost function to discourage the model from learning overly complex relationships. Regularization can shrink the coefficients of less important features to zero, effectively performing feature selection. L1 regularization (LASSO) tends to perform feature selection by shrinking some coefficients to exactly zero, while L2 regularization (Ridge) shrinks all coefficients towards zero but rarely to exactly zero. Elastic Net combines L1 and L2 regularization.</li>
</ul>
</section>
<section id="validation-continued" class="level3">
<h3 class="anchored" data-anchor-id="validation-continued">8. Validation (Continued)</h3>
<p><strong>Qualitative Validation:</strong> Qualitative validation involves assessing the model’s validity based on non-quantitative factors, such as:</p>
<ul>
<li><strong>Use Tests:</strong> Ensuring that the model is used appropriately for its intended purpose.</li>
<li><strong>Data Quality:</strong> Verifying that the data used to train and validate the model is accurate, complete, and relevant.</li>
<li><strong>Documentation:</strong> Documenting the model’s development, assumptions, limitations, and validation results.</li>
<li><strong>Senior Management Approval:</strong> Obtaining senior management approval for the model’s use.</li>
</ul>
<p><strong>Quantitative Validation:</strong> Quantitative validation involves assessing the model’s performance using quantitative metrics. This is essential for ensuring that the model is accurate and reliable.</p>
<ul>
<li><strong>Discrimination:</strong> Measures the model’s ability to distinguish between different outcome groups (e.g., default vs.&nbsp;non-default). Key metrics include:
<ul>
<li><strong>AUC (Area Under the ROC Curve):</strong> A measure of the model’s ability to rank observations correctly. A higher AUC indicates better discrimination.</li>
<li><strong>Accuracy Ratio (AR) / Gini Coefficient:</strong> Related to the AUC, providing a similar measure of discriminatory power.</li>
<li><strong>KS Statistic (Kolmogorov-Smirnov Statistic):</strong> Measures the maximum separation between the cumulative distribution functions of the two outcome groups.</li>
</ul></li>
<li><strong>Calibration:</strong> Measures how well the model’s predicted probabilities align with the observed event rates. Key metrics include:
<ul>
<li><strong>Brier Score:</strong> Mean squared error of the predicted probabilities. A lower Brier Score indicates better calibration.</li>
<li><strong>R-squared (Calibration R-squared):</strong> The R-squared from regressing the observed outcomes on the predicted probabilities.</li>
<li><strong>Calibration Curve (Reliability Diagram):</strong> A plot of observed event rates against predicted probabilities. A well-calibrated model will have a calibration curve close to the diagonal line.</li>
<li><strong>Hosmer-Lemeshow Test:</strong> A statistical test for assessing calibration.</li>
</ul></li>
<li><strong>Stability:</strong> Measures the model’s consistency over time. Key metrics include:
<ul>
<li><strong>Population Stability Index (PSI):</strong> Measures the change in the distribution of predicted probabilities over time.</li>
<li><strong>Characteristic Stability Index (CSI):</strong> Measures the change in the distribution of feature values over time.</li>
</ul></li>
</ul>
<p><strong>Backtesting:</strong> A critical aspect of model validation, involving evaluating the model’s performance on out-of-time data (data not used for model training or hyperparameter tuning). This is particularly important for credit risk models, as they are used to predict future events. Backtesting involves comparing the model’s predictions with the actual outcomes that occurred in the out-of-time period. Key metrics include:</p>
<ul>
<li><strong>AUC (Out-of-Time AUC):</strong></li>
<li><strong>Brier Score (Out-of-Time Brier Score):</strong></li>
<li><strong>Calibration Curve (Out-of-Time Calibration Curve):</strong></li>
</ul>
<p><strong>Other Validation Techniques:</strong></p>
<ul>
<li><strong>Stress Testing:</strong> Evaluating the model’s performance under stressed economic scenarios. This helps to assess the model’s robustness to adverse conditions.</li>
<li><strong>Sensitivity Analysis:</strong> Assessing the impact of changes in model inputs (features) on model outputs (predictions).</li>
</ul>
</section>
</section>
<section id="part-iii-default-payoff-lgd-and-ead-modeling-continued" class="level2">
<h2 class="anchored" data-anchor-id="part-iii-default-payoff-lgd-and-ead-modeling-continued">Part III: Default, Payoff, LGD and EAD Modeling (Continued)</h2>
<section id="default-modeling-continued" class="level3">
<h3 class="anchored" data-anchor-id="default-modeling-continued">9. Default Modeling (Continued)</h3>
<p><strong>Default Indicators:</strong> A binary variable indicating whether a loan has defaulted in a given period. This is the target variable in default prediction models.</p>
<p><strong>Default Models:</strong> Statistical models used to estimate the probability of default (PD).</p>
<ul>
<li><strong>Logistic Regression:</strong> A widely used model for binary classification problems, including default prediction. The logistic regression model estimates the probability of default as a function of a linear combination of features. The logistic function maps the linear predictor to a probability between 0 and 1.</li>
</ul>
<pre><code>PD = 1 / (1 + exp(-β'x))</code></pre>
<ul>
<li><strong>Probit Regression:</strong> Similar to logistic regression, but uses the probit function (cumulative standard normal distribution) instead of the logistic function.</li>
</ul>
<p><strong>Generalized Linear Models (GLMs):</strong> A framework for modeling various types of outcomes, including binary outcomes like default. GLMs allow for different link functions (e.g., logistic, probit) to connect the linear predictor to the expected value of the outcome variable.</p>
<p><strong>Forecasting PDs:</strong> Using historical data and statistical models to predict future probabilities of default.</p>
<ul>
<li><strong>Training and Test Sample:</strong> Dividing the data into training and testing sets is crucial for evaluating the model’s ability to generalize to new, unseen data.</li>
<li><strong>Point-in-Time (PIT) PDs:</strong> PDs that reflect the current economic conditions and are forward-looking.</li>
<li><strong>Through-the-Cycle (TTC) PDs:</strong> PDs that are less sensitive to short-term economic fluctuations and represent a long-run average default rate.</li>
</ul>
<p><strong>Crisis PDs:</strong> Estimating PDs under stressed economic scenarios for stress testing and capital planning purposes.</p>
<ul>
<li><strong>Asymptotic Single Risk Factor (ASRF) Model:</strong> A widely used model for estimating portfolio credit risk and calculating regulatory capital requirements. The ASRF model assumes that the asset returns of borrowers are driven by a single systematic risk factor and idiosyncratic risk factors.</li>
</ul>
<pre><code>Ri = -√ρF + √(1 - ρ)εi</code></pre>
<p>where:</p>
<ul>
<li>Ri is the asset return of borrower i.</li>
<li>F is the systematic risk factor.</li>
<li>ρ is the asset correlation.</li>
<li>εi is the idiosyncratic risk factor for borrower i.</li>
</ul>
<p><strong>Conditional Probability of Default (CPD):</strong> The probability of default for a borrower given a specific value of the systematic risk factor.</p>
<pre><code>CPDi(F) = Φ((ci + √ρF) / √(1 - ρ))</code></pre>
<p>where:</p>
<ul>
<li>ci is the default threshold for borrower i.</li>
<li>Φ is the cumulative standard normal distribution.</li>
</ul>
<p><strong>Worst-Case PD (WCPD):</strong> The PD under a stressed scenario, typically corresponding to a low percentile of the systematic risk factor distribution (e.g., 1st percentile).</p>
<pre><code>WCPD = Φ((Φ^-1(PD) + √ρΦ^-1(α)) / √(1 - ρ))</code></pre>
<p>where α is the confidence level (typically 0.999 for Basel capital calculations).</p>
<p><strong>Low Default Portfolios:</strong> Special techniques for estimating PDs when default data is scarce, such as in portfolios of sovereign or corporate loans.</p>
<ul>
<li><strong>Most Prudent Estimate (MPE):</strong> A method for estimating PDs under the assumption of monotonicity (PDs increase with risk rating).</li>
</ul>
</section>
<section id="payoff-modeling-continued" class="level3">
<h3 class="anchored" data-anchor-id="payoff-modeling-continued">10. Payoff Modeling (Continued)</h3>
<p><strong>Payoff Indicators:</strong> A binary variable indicating whether a loan has been prepaid (fully or partially) in a given period.</p>
<p><strong>Payoff Models:</strong> Similar to default models, payoff models predict the probability of prepayment (PP).</p>
<ul>
<li><strong>Logistic Regression:</strong></li>
<li><strong>Probit Regression:</strong></li>
<li><strong>Multinomial Logit Model:</strong> This model can be used to simultaneously model default, payoff, and survival. It estimates the probabilities of each outcome as a function of features.</li>
</ul>
<p><strong>Selection Control:</strong> Payoff can introduce selection bias into default models, as borrowers who prepay are often systematically different from those who do not. Addressing this selection bias is crucial for accurate default prediction. Techniques for handling selection bias include:</p>
<ul>
<li><strong>Joint Modeling:</strong> Simultaneously modeling default and payoff using a multinomial model (e.g., multinomial logit) or a bivariate model.</li>
<li><strong>Two-Stage Modeling:</strong> Modeling payoff in the first stage and including the predicted probability of payoff as a feature in the second-stage default model.</li>
</ul>
</section>
<section id="lgd-modeling-continued" class="level3">
<h3 class="anchored" data-anchor-id="lgd-modeling-continued">11. LGD Modeling (Continued)</h3>
<p><strong>LGD Models:</strong> Statistical models used to estimate Loss Given Default (LGD).</p>
<ul>
<li><strong>Linear Regression:</strong> A simple linear regression model can be used to predict LGD as a function of features. However, linear regression assumes that the errors are normally distributed and that the relationship between the features and LGD is linear. These assumptions may not hold in practice.</li>
</ul>
<pre><code>LGD = β'x + ε</code></pre>
<ul>
<li><strong>Transformed Linear Regression:</strong> Applying a transformation (e.g., logit transformation) to the LGD values can improve model performance if the LGD distribution is non-normal or if there are boundary issues (LGD values close to 0 or 1).</li>
</ul>
<pre><code>logit(LGD) = β'x + ε</code></pre>
<ul>
<li><strong>Fractional Response Regression:</strong> This approach models the expected value of LGD directly, addressing the boundary issues of LGD values. It is often based on a quasi-likelihood estimation.</li>
</ul>
<pre><code>E(LGD) = F(β'x)</code></pre>
<p>where F(.) is a link function (e.g., logistic function).</p>
<ul>
<li><strong>Beta Regression:</strong> This model assumes that LGD follows a beta distribution, which is naturally bounded between 0 and 1. Beta regression models both the mean and the dispersion of the LGD distribution.</li>
</ul>
<p><strong>Forecasting LGDs:</strong> Similar to PD forecasting, LGD models can be used to predict future LGDs. It is important to consider the time dimension and potential changes in macroeconomic conditions.</p>
</section>
<section id="exposure-modeling-continued" class="level3">
<h3 class="anchored" data-anchor-id="exposure-modeling-continued">12. Exposure Modeling (Continued)</h3>
<p><strong>Exposure at Default (EAD):</strong> The outstanding loan amount at the time of default. EAD modeling aims to predict the EAD for loans that have not yet defaulted. This is crucial for estimating potential future losses.</p>
<p><strong>Credit Conversion Measures:</strong> These measures are used to standardize EADs for different loan types and credit facilities, allowing for comparison and aggregation across different portfolios.</p>
<ul>
<li><strong>Credit Conversion Factor (CCF):</strong> Represents the proportion of undrawn credit that is expected to be drawn at the time of default. Primarily used for credit lines and revolving credit facilities.</li>
<li><strong>Credit Equivalent Amount (CEA):</strong> The EAD adjusted for credit risk mitigation techniques, such as collateralization.</li>
<li><strong>Drawdown LGD:</strong> In some cases, institutions might define LGD as the percentage of the maximum exposure (e.g., credit line limit) that is lost in the event of default, rather than the percentage of the outstanding balance at default.</li>
</ul>
<p><strong>EAD Modeling Techniques:</strong> Similar techniques as for LGD modeling can be applied to EAD modeling, including linear regression, transformed linear regression, and beta regression.</p>
</section>
</section>
<section id="part-iv-machine-learning-for-pd-and-lgd-forecasting-continued" class="level2">
<h2 class="anchored" data-anchor-id="part-iv-machine-learning-for-pd-and-lgd-forecasting-continued">Part IV: Machine Learning for PD and LGD Forecasting (Continued)</h2>
<section id="standalone-techniques-continued" class="level3">
<h3 class="anchored" data-anchor-id="standalone-techniques-continued">13. Standalone Techniques (Continued)</h3>
<p>This chapter explores various standalone machine learning techniques for PD and LGD forecasting.</p>
<p><strong>K-Nearest Neighbors (KNN):</strong> A non-parametric method that classifies (for PD) or predicts (for LGD) an observation based on the majority class or average value of its k-nearest neighbors in the feature space. The choice of k (number of neighbors) is a crucial hyperparameter that controls the model’s complexity.</p>
<p><strong>Naive Bayes:</strong> A simple and efficient classification algorithm based on Bayes’ theorem and the assumption of feature independence. While the independence assumption is often violated in practice, Naive Bayes can still perform surprisingly well in some cases. It is particularly useful for high-dimensional datasets.</p>
<p><strong>Decision Trees:</strong> A tree-based model that recursively partitions the feature space into homogeneous regions based on feature splits. Decision trees are easy to interpret and can capture non-linear relationships between features and the outcome variable. However, individual decision trees are prone to overfitting.</p>
<p><strong>Support Vector Machines (SVM):</strong> A powerful classification algorithm that finds a hyperplane that maximizes the margin between classes. SVMs can capture non-linear relationships using kernel functions, which map the data to a higher-dimensional space.</p>
<p><strong>Hyperparameter Tuning:</strong> Most machine learning algorithms have hyperparameters that control their complexity and learning behavior. Tuning these hyperparameters is crucial for achieving optimal model performance. Common hyperparameter tuning techniques include:</p>
<ul>
<li><strong>Grid Search:</strong> Systematically evaluating the model’s performance for different combinations of hyperparameter values.</li>
<li><strong>Random Search:</strong> Randomly sampling hyperparameter values from a specified distribution.</li>
<li><strong>Bayesian Optimization:</strong> Using a Bayesian approach to optimize hyperparameter values.</li>
</ul>
</section>
<section id="neural-networks-and-deep-learning-continued" class="level3">
<h3 class="anchored" data-anchor-id="neural-networks-and-deep-learning-continued">14. Neural Networks and Deep Learning (Continued)</h3>
<p>This chapter explores neural networks, a powerful class of machine learning models inspired by the structure and function of the human brain.</p>
<p><strong>Multi-layer Perceptron (MLP):</strong> The most common type of neural network, consisting of an input layer, one or more hidden layers, and an output layer. Each layer is composed of interconnected nodes (neurons) that process and transform the data.</p>
<p><strong>Activation Functions:</strong> Non-linear functions that introduce non-linearity into the model. Common activation functions include:</p>
<ul>
<li><strong>Sigmoid:</strong> Maps values to the range [0, 1].</li>
<li><strong>ReLU (Rectified Linear Unit):</strong> Returns the maximum of 0 and the input value.</li>
<li><strong>Tanh (Hyperbolic Tangent):</strong> Maps values to the range [-1, 1].</li>
</ul>
<p><strong>Backpropagation:</strong> An algorithm for training neural networks by iteratively adjusting the weights of the connections between neurons to minimize the loss function.</p>
<p><strong>Deep Learning:</strong> Neural networks with multiple hidden layers. Deep learning models can learn complex non-linear relationships in the data.</p>
</section>
<section id="ensemble-techniques-continued" class="level3">
<h3 class="anchored" data-anchor-id="ensemble-techniques-continued">15. Ensemble Techniques (Continued)</h3>
<p><strong>Bagging (Bootstrap Aggregating):</strong> Training multiple models on different bootstrapped samples of the training data and aggregating their predictions. Bagging reduces variance and improves model stability.</p>
<p><strong>Boosting:</strong> Sequentially training models, giving more weight to misclassified observations in subsequent iterations. Boosting reduces bias and improves model accuracy.</p>
<p><strong>Random Forests:</strong> An ensemble of decision trees trained using bagging and random feature selection. Random forests are robust and accurate and can handle high-dimensional datasets.</p>
<p><strong>Boosted Trees:</strong> An ensemble of decision trees trained using boosting. Popular boosted tree algorithms include:</p>
<ul>
<li><strong>AdaBoost (Adaptive Boosting):</strong></li>
<li><strong>Gradient Boosting:</strong></li>
<li><strong>XGBoost (Extreme Gradient Boosting):</strong></li>
<li><strong>LightGBM (Light Gradient Boosting Machine):</strong></li>
</ul>
<p><strong>Voting Classifier/Regressor:</strong> Combining predictions from multiple different models using majority voting (for classification) or averaging (for regression).</p>
</section>
<section id="machine-learning-for-lgd-continued" class="level3">
<h3 class="anchored" data-anchor-id="machine-learning-for-lgd-continued">16. Machine Learning for LGD (Continued)</h3>
<p>Applying machine learning techniques to LGD modeling, using regression methods instead of classification methods. Commonly used techniques include linear regression, regularized regression (Ridge, LASSO), KNN, decision trees, random forests, boosted trees, support vector regression (SVR), and neural networks.</p>
</section>
</section>
<section id="part-v-synthesis-lifetime-modeling-ifrs-9cecl-loan-pricing-and-credit-portfolio-risk-continued" class="level2">
<h2 class="anchored" data-anchor-id="part-v-synthesis-lifetime-modeling-ifrs-9cecl-loan-pricing-and-credit-portfolio-risk-continued">Part V: Synthesis: Lifetime Modeling, IFRS 9/CECL, Loan Pricing, and Credit Portfolio Risk (Continued)</h2>
<section id="multi-period-modeling-continued" class="level3">
<h3 class="anchored" data-anchor-id="multi-period-modeling-continued">17. Multi-period Modeling (Continued)</h3>
<p>This chapter focuses on extending the models discussed earlier to a multi-period setting, which is essential for lifetime loss provisioning and loan pricing.</p>
<p><strong>Term Structures:</strong> Modeling risk measures (PD, LGD, EAD) as functions of time, vintage, and age.</p>
<p><strong>Roll Rate Analysis:</strong> Analyzing rating migration patterns over time, often represented by transition matrices.</p>
<p><strong>Survival Time Models:</strong> Modeling the time to default using survival analysis techniques. These models are particularly useful for capturing the time dimension of credit risk.</p>
<ul>
<li><strong>Cox Proportional Hazard (CPH) Model:</strong> A popular survival model that assumes a proportional hazard rate. The hazard rate is the instantaneous probability of default at a given time, conditional on surviving up to that time. The CPH model expresses the hazard rate as a product of a baseline hazard function and a function of covariates.</li>
</ul>
<pre><code>h(t|x) = h0(t) * exp(β'x)</code></pre>
<p>where:</p>
<ul>
<li>h(t|x) is the hazard rate at time t for an individual with covariate vector x.</li>
<li>h0(t) is the baseline hazard function.</li>
<li>β is the vector of coefficients.</li>
</ul>
<p><strong>Survival Function:</strong> The probability of surviving beyond time t.</p>
<p><strong>Hazard Function:</strong> The instantaneous rate of default at time t, given survival up to time t.</p>
</section>
<section id="expected-credit-losses-continued" class="level3">
<h3 class="anchored" data-anchor-id="expected-credit-losses-continued">18. Expected Credit Losses (Continued)</h3>
<p><strong>Expected Loss (EL):</strong> The expected value of the loss on a loan or portfolio over a given period or lifetime.</p>
<p><strong>1-Year EL:</strong> The expected loss over a one-year horizon.</p>
<p><strong>Lifetime EL (LEL):</strong> The expected loss over the lifetime of the loan. LEL is calculated by summing the discounted expected losses for each future period, considering the probabilities of default, payoff, and survival.</p>
<p><strong>IFRS 9/CECL:</strong> International Financial Reporting Standard 9 (IFRS 9) and the Current Expected Credit Loss (CECL) standard in the US require banks to provision for lifetime expected losses on financial instruments. This represents a significant change from the previous incurred loss model.</p>
<p><strong>Stages of Credit Losses (IFRS 9):</strong></p>
<ul>
<li><strong>Stage 1:</strong> Performing loans with no significant increase in credit risk. Provision for 12-month EL.</li>
<li><strong>Stage 2:</strong> Performing loans with a significant increase in credit risk. Provision for lifetime EL.</li>
<li><strong>Stage 3:</strong> Impaired loans. Provision for lifetime EL.</li>
</ul>
<p><strong>Significant Increase in Credit Risk (SICR):</strong> A significant increase in credit risk is defined as a substantial deterioration in the credit quality of a loan since initial recognition. Various methods can be used to assess SICR, including comparing the current PD with the PD at origination or evaluating changes in credit ratings.</p>
<p><strong>Loan Pricing:</strong> Incorporating expected and unexpected losses into loan pricing models to ensure that the loan price adequately compensates the lender for the risk of default.</p>
</section>
<section id="unexpected-credit-losses-continued" class="level3">
<h3 class="anchored" data-anchor-id="unexpected-credit-losses-continued">19. Unexpected Credit Losses (Continued)</h3>
<p>This chapter focuses on modeling unexpected credit losses, which are losses that exceed the expected loss.</p>
<p><strong>Value-at-Risk (VaR):</strong> A statistical measure of risk that represents the maximum potential loss on a portfolio over a given time horizon at a specified confidence level. For example, a 99.9% one-year VaR represents the loss that is expected to be exceeded only 0.1% of the time over a one-year horizon.</p>
<p><strong>Conditional Value-at-Risk (CVaR) / Expected Shortfall (ES):</strong> A coherent risk measure that represents the expected loss conditional on exceeding VaR. CVaR provides a more comprehensive measure of tail risk compared to VaR.</p>
<p><strong>Asset Correlation (ρ):</strong> A measure of the dependence between defaults in a portfolio. Asset correlation is a crucial parameter in credit portfolio models, as it affects the diversification benefit of holding a portfolio of loans.</p>
<p><strong>Credit Portfolio Loss Distributions:</strong> Modeling the distribution of losses in a credit portfolio. Various methods can be used to model portfolio loss distributions, including:</p>
<ul>
<li><strong>Analytical Methods (e.g., ASRF Model):</strong> Suitable for large, homogeneous portfolios.</li>
<li><strong>Numerical Integration:</strong> Can handle limited granularity.</li>
<li><strong>Monte Carlo Simulation:</strong> A flexible approach that can handle heterogeneous portfolios and complex dependencies.</li>
</ul>
</section>
<section id="outlook-continued" class="level3">
<h3 class="anchored" data-anchor-id="outlook-continued">20. Outlook (Continued)</h3>
<p>This chapter discusses the current trends and future directions in credit risk analytics, including the increasing use of machine learning, big data, and alternative data sources. It also highlights the challenges and opportunities presented by new regulations, such as IFRS 9 and CECL. The chapter emphasizes the importance of staying up-to-date with the latest developments in the field and adapting to the changing landscape of credit risk management.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/lktuan\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><span class="faux-block"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><i class="fa-brands fa-creative-commons" aria-label="creative-commons"></i></a> 2023-2025 Le Khac Tuan</span></p>
</div>   
    <div class="nav-footer-center">
<p><span class="faux-block"> Designed with <i class="fa-solid fa-heart" aria-label="heart"></i>, <span id="commit-info">Loading last commit…</span> </span></p>
</div>
    <div class="nav-footer-right">
<p><span class="faux-block">Made with <a href="https://quarto.org/">Quarto</a></span></p>
</div>
  </div>
</footer>
<script type="application/javascript" src="commit_info.js"></script>




</body></html>