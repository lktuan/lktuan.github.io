---
title: "Python is cool"
description: "Unknown Python's features"
author:
  - name: "Tuan Le Khac"
    url: https://lktuan.github.io/
date: 05-21-2024
categories: [Python, Lambda] # self-defined categories
image: julia_logo.jpg
draft: true # setting this to `true` will prevent your post from appearing on your listing page until you're ready!

format: 
  html: 
    code-fold: false
    code-summary: "Show the code"
    code-line-numbers: true
css: html/styles.scss
editor: visual
---

# 1. Motivation

------------------------------------------------------------------------

ƒê√¢y l√† m·ªôt b√†i th·ª±c h√†nh theo m·ªôt [post](https://github.com/chiphuyen/python-is-cool/tree/master) b·ªüi ch·ªã [Chip Huyen](https://huyenchip.com/) v·ªÅ m·ªôt s·ªë features ƒë·∫∑c bi·ªát c·ªßa Python. L√† m·ªôt DA kh√¥ng s·ª≠ d·ª•ng Python qu√° nhi·ªÅu, ch·ªâ m·ªôt s·ªë feature d∆∞·ªõi ƒë√¢y l√† m√¨nh ƒë√£ t·ª´ng *nghe* qua. Hi v·ªçng b√†i th·ª±c h√†nh s·∫Ω gi√∫p m√¨nh h·ª©ng th√∫ v·ªõi Python h∆°n!

# 2. Lambda, map, filter, & reduce

------------------------------------------------------------------------

Lambda cho ph√©p ng∆∞·ªùi d√πng ƒë·ªãnh nghƒ©a in-line functions. Vi·ªác s·ª≠ d·ª•ng `lambda()` r·∫•t thu·∫≠n ti·ªán khi g·ªçi l·∫°i (callback \~ m·ªôt function ƒë∆∞·ª£c th·ª±c thi sau khi m·ªôt function kh√°c ƒë∆∞·ª£c th·ª±c thi; m·ªôt c√°ch l∆∞u tr·ªØ function) ho·∫∑c khi ƒë·∫ßu ra c·ªßa m·ªôt function l√† ƒë·ªëi s·ªë cho m·ªôt function kh√°c.

Hai h√†m `square_fn` v√† `square_ld` d∆∞·ªõi ƒë√¢y l√† m·ªôt:

```{python}
def square_fn(x):
    return x * x

square_ld = lambda x : x * x

for i in range(10):
    assert square_fn(i) == square_ld(i)
```

`lambda` r·∫•t h·ªØu √≠ch khi s·ª≠ d·ª•ng c√πng v·ªõi c√°c function kh√°c nh∆∞ `map`, `filter`, v√† `reduce` (m√¨nh r·∫•t hay s·ª≠ d·ª•ng pattern n√†y tr√™n Excel üòÇ). `map(fn, interable)` s·∫Ω apply h√†m `fn` cho t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ trong `iterable` (nh∆∞ list, set, dict, tuple, string), tr·∫£ v·ªÅ map object.

```{python}
nums = [1/3, 2/7, 1001/37500, 40/27]
nums_squared = [num * num for num in nums]
print(nums_squared)
```

D√πng `map` v√† m·ªôt h√†m callback, cho ra k·∫øt qu·∫£ t∆∞∆°ng ƒë∆∞∆°ng:

```{python}
nums_squared_1 = map(square_fn, nums)
nums_squared_2 = map(lambda x: x*x, nums)
print(list(nums_squared_1)) # list to list the elements of map object
print(list(nums_squared_2))
```

C√≥ th·ªÉ d√πng `map` v·ªõi nhi·ªÅu h∆°n 1 iterable. V√≠ d·ª• mu·ªën t√≠nh MSE cho m·ªôt h·ªìi quy tuy·∫øn t√≠nh ƒë∆°n gi·∫£n `f(x) = ax + b` v·ªõi ground tru `labels`, hai ph∆∞∆°ng ph√°p sau t∆∞∆°ng ƒë∆∞∆°ng:

```{python}
a, b = 3, -0.5
xs = [2, 3, 4, 5]
labels = [6.4, 8.9, 10.9, 15.3]

# Ph∆∞∆°ng ph√°p 1, loop
errors = []
for i,x in enumerate(xs):
    errors.append( (a * x + b - labels[i])**2 )
result_1 = sum(errors)**(1/2) / len(xs)

# Ph∆∞∆°ng ph√°p 2, map
diff = map(lambda x, y: (a * x + b - y) ** 2, xs, labels) 
result_2 = sum(diff)**.5 / len(xs)

print(result_1, result_2)
```

`filter(fn, iterable)` gi·ªëng nh∆∞ `map`, tuy nhi√™n `fn` l√† m·ªôt h√†m tr·∫£ v·ªÅ gi√° tr·ªã boolean true/false, v√† `filter` s·∫Ω tr·∫£ v·ªÅ c√°c ph·∫ßn t·ª≠ c·ªßa `iterable` khi `fn` tr·∫£ v·ªÅ true.

```{python}
bad_preds = filter(lambda x: x > 0.5, errors)

print(list(bad_preds))
```

`reduce(fn, iterable, initializer)` ƒë∆∞·ª£c d√πng khi ta mu·ªën √°p d·ª•ng m·ªôt to√°n l√™n t·∫•t c·∫£ th√†nh ph·∫ßn trong danh s√°ch. V√≠ d·ª• mu·ªën t√≠nh k·∫øt qu·∫£ nh√¢n c·ªßa to√†n b·ªô ph·∫ßn t·ª≠:

```{python}
product = 1
for num in nums:
    product *= num
print(product)
```

S·ª≠ d·ª•ng `reduce`:

```{python}
from functools import reduce

product = reduce(lambda x, y: x * y, nums)
print(product)
```

### Hi·ªáu su·∫•t h√†m Lambda

Lambda ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ s·ª≠ d·ª•ng m·ªôt l·∫ßn. M·ªói l·∫ßn ƒë∆∞·ª£c g·ªçi, h√†m `lambda x: dosomething(x)` ƒë·ªÅu ƒë∆∞·ª£c t·∫°o l·∫°i, v√† do ƒë√≥ ·∫£nh h∆∞·ªüng t·ªõi hi·ªáu su·∫•t.

Khi h√†m lambda ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a tr∆∞·ªõc `fn = lambda x: dosomething(x)`, hi·ªáu su·∫•t c·ªßa n√≥ v·∫´n ch·∫≠m h∆°n `def`, tuy nhi√™n kh√¥ng [ƒë√°ng k·ªÉ](https://stackoverflow.com/questions/26540885/lambda-is-slower-than-function-call-in-python-why).

üöÄNguy√™n vƒÉn ch·ªã Chip:

> Even though I find lambdas cool, I personally recommend using named functions when you can for the sake of clarity.

# 3. List manipulation

------------------------------------------------------------------------

## 3.1. Unpacking

Ch√∫ng ta c√≥ th·ªÉ "gi·∫£i n√©n" m·ªôt list nh∆∞ th·∫ø n√†y:

```{python}
elems = [1,2,3,4]
a,b,c,d = elems

print(a,b,c,d)
```

C≈©ng c√≥ th·ªÉ l√†m nh∆∞ th·∫ø n√†y:

```{python}
a, *new_elems, d = elems # remember the char * for extended unpacking

print(a)
print(new_elems)
print(b)
```

## 3.2. Slicing

Ch√∫ng ta c√≥ th·ªÉ reverse/ƒë·∫£o ng∆∞·ª£c m·ªôt list v·ªõi `[::-1]`

```{python}
elem = list(range(10))
print(elem)


print(elem[::-1])
```

C√∫ ph√°p `[x:y:z]` c√≥ nghƒ©a l√† l·∫•y ***m·ªói*** ph·∫ßn t·ª≠ th·ª© `z` t·ª´ index `x` t·ªõi index `y`. Khi `z` √¢m, t∆∞∆°ng ƒë∆∞∆°ng v·ªõi vi·ªác l·∫•y theo th·ª© t·ª± ng∆∞·ª£c l·∫°i. `x` ƒë·ªÉ tr·ªëng ch·ªâ vi·ªác l·∫•y t·ª´ ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n, `y` ƒë·ªÉ r·ªóng ch·ªâ vi·ªác l·∫•y t·ªõi ph·∫ßn t·ª≠ cu·ªëi c√πng.

```{python}
evens = elem[::2]
print(evens)

reversed_evens = elem[2::-2]
print(reversed_evens)
```

C≈©ng c√≥ th·ªÉ d√πng slicing ƒë·ªÉ x√≥a c√°c ph·∫ßn t·ª≠ nh∆∞ th·∫ø n√†y:

```{python}
del elems[::2]
print(elems)
```

## 3.3. Insertion

Ch√∫ng ta c√≥ th·ªÉ thay ƒë·ªïi gi√° tr·ªã m·ªôt ph·∫ßn t·ª≠ trong m·ªôt list nh∆∞ sau:

```{python}
elems = list(range(10))

elems[1] = 100
print(elems)
```

C≈©ng c√≥ th·ªÉ thay th·∫ø m·ªôt gi√° tr·ªã b·∫±ng nhi·ªÅu gi√° tr·ªã:

```{python}
elems = list(range(10))
elems[1:2] = [20, 30, 40]
print(elems)
```

N·∫øu ch√∫ng ta mu·ªën th√™m 3 gi√° tr·ªã `0.3, 0.4, 0.5` v√†o gi·ªØa ph·∫ßn t·ª≠ th·ª© 0 v√† 1 c·ªßa list n√†y, th√¨:

```{python}
elems = list(range(10))
elems[1:1] = [.3, .4, .5]
print(elems)
```

## 3.4. Flattening

Ch√∫ng ta c√≥ th·ªÉ flatten m·ªôt list s·ª≠ dung `sum(0)`:

```{python}
list_of_lists = [[1], [2, 3], [4, 5, 6]]
sum(list_of_lists, [])
```

C≈©ng c√≥ th·ªÉ s·ª≠ d·ª•ng recursive lambda (another beauty of lambda)

```{python}
nested_lists = [[1, 2], [[3, 4], [5, 6], [[7, 8], [9, 10], [[11, [12, 13]]]]]]
flatten = lambda x: [y for i in x for y in flatten(i)] if type(x) is list else [x]

print(flatten(nested_lists))

# This line of code is from
# https://github.com/sahands/python-by-example/blob/master/python-by-example.rst#flattening-lists
```

## 3.5. List vs Generator

üöÄGenerator l√† c√°i g√¨ v·∫≠y? Tr√≠ch [b√†i vi·∫øt](https://manhhomienbienthuy.github.io/2016/01/05/python-iterator-generator.html):

> T·ª´ generator ƒë∆∞·ª£c s·ª≠ d·ª•ng cho c·∫£ h√†m (h√†m generator l√† h√†m ƒë√£ n√≥i ·ªü tr√™n) v√† k·∫øt qu·∫£ m√† h√†m ƒë√≥ sinh ra (ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c h√†m generator sinh ra c≈©ng ƒë∆∞·ª£c g·ªçi l√† generator). V√¨ v·∫≠y ƒë√¥i khi vi·ªác n√†y g√¢y kh√≥ hi·ªÉu m·ªôt ch√∫t. H√£y xem v√≠ d·ª• v·ªÅ vi·ªác t·∫°o n-grams t·ª´ m·ªôt danh s√°ch tokens d∆∞·ªõi ƒë√¢y ƒë·ªÉ hi·ªÉu s·ª± kh√°c bi·ªát gi·ªØa list v√† generator:

```{python}
tokens = ['i', 'want', 'to', 'go', 'to', 'school']

def ngrams(tokens, n):
    length = len(tokens)
    grams = []
    for i in range(length - n + 1):
        grams.append(tokens[i:i+n])
    return grams

print(ngrams(tokens, 3))
```

Trong v√≠ d·ª• n√†y, ch√∫ng ta ph·∫£i l∆∞u to√†n b·ªô n-grams m·ªôt l√∫c. N·∫øu c√≥ `m` tokens, memory requirement l√† `O(nm)` - s·∫Ω l√† v·∫•n ƒë·ªÅ n·∫øu `m` l·ªõn. Thay v√†o ƒë√≥, ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng generator ƒë·ªÉ t·∫°o n-grams ti·∫øp theo khi ƒë∆∞·ª£c y√™u c·∫ßu. ƒê√¢y g·ªçi l√† lazy evaluation. Ch√∫ng ta c√≥ th·ªÉ t·∫°o m·ªôt h√†m `ngrams` tr·∫£ v·ªÅ m·ªôt generator s·ª≠ d·ª•ng keyword `yield`, l√∫c n√†y memory requirement l√† `O(n+m)`.

```{python}
def ngrams(tokens, n):
    length = len(tokens)
    for i in range(length - n + 1):
        yield tokens[i:i+n]

ngrams_generator = ngrams(tokens, 3)
print(ngrams_generator)

for ngram in ngrams_generator:
    print(ngram)
```

M·ªôt c√°ch kh√°c ƒë·ªÉ t·∫°o n-grams l√† slice ƒë·ªÉ l·∫•y c√°c sub-list `[0, 1, 2, ...,-n]`, `[1, 2, 3, ...,-n+1]`, `[2, 3, 4, ...,-n+2]`,... `[n-1, n, ...,-1]`, sau ƒë√≥ `zip` ch√∫ng l·∫°i:

```{python}
def ngrams(tokens, n):
    length = len(tokens)
    slices = (tokens[i:length-n+i+1] for i in range(n))
    return zip(*slices)

ngrams_generator = ngrams(tokens, 3)
print(ngrams_generator)


for ngram in ngrams_generator:
    print(ngram)
```

L∆∞u √Ω ch√∫ng ta s·ª≠ d·ª•ng `(tokens[...] for i in range(n))`, ch·ª© kh√¥ng ph·∫£i `[tokens[...] for i in range(n)]`. `[]` tr·∫£ v·ªÅ m·ªôt list, `()` tr·∫£ v·ªÅ generator. \# 4. Classes & magic methods

------------------------------------------------------------------------

Trong Python, magic methods ƒë∆∞·ª£c prefixed v√† suffixed b·ªüi double underscore `__` (aka dunder). Magic method ƒë∆∞·ª£c bi·∫øt ƒë·∫øn r·ªông r√£i nh·∫•t l√† `__init__`.

```{python}
class Node:
    """ A struct to denote the node of a binary tree.
    It contains a value and pointers to left and right children.
    """
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
```

In ra object, tuy nhi√™n nh√¨n kh√¥ng t∆∞·ªùng minh l·∫Øm!

```{python}
root = Node(5)
print(root) # <__main__.Node object at 0x1069c4518>
```

Ch√∫ng ta mong mu·ªën khi in ra m·ªôt Node, gi√° tr·ªã c·ªßa n√≥ c≈©ng nh∆∞ gi√° tr·ªã c·ªßa c√°c Node con (n·∫øu c√≥) c≈©ng s·∫Ω ƒë∆∞·ª£c in ra. Ch√∫ng ta d√πng `__repr__`:

```{python}
class Node:
    """ A struct to denote the node of a binary tree.
    It contains a value and pointers to left and right children.
    """
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

    def __repr__(self):
        strings = [f'value: {self.value}']
        strings.append(f'left: {self.left.value}' if self.left else 'left: None')
        strings.append(f'right: {self.right.value}' if self.right else 'right: None')
        return ', '.join(strings)

left = Node(4)
root = Node(5, left)
print(root) # value: 5, left: 4, right: None
```

Ch√∫ng ta c≈©ng mu·ªën hai Node c√≥ th·ªÉ ƒë∆∞·ª£c so s√°nh ƒë∆∞·ª£c v·ªõi nhau, v√¨ th·∫ø t·∫°o ra c√°c magic method ƒë·ªÉ implement c√°c operator: `==` v·ªõi `__eq__`, `>` v·ªõi `__lt__`, '\>=' v·ªõi `__ge__`:

```{python}
class Node:
    """ A struct to denote the node of a binary tree.
    It contains a value and pointers to left and right children.
    """
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

    def __eq__(self, other):
        return self.value == other.value

    def __lt__(self, other):
        return self.value < other.value

    def __ge__(self, other):
        return self.value >= other.value


left = Node(4)
root = Node(5, left)
print(left == root) # False
print(left < root) # True
print(left >= root) # False
```

Xem [·ªü ƒë√¢y](https://www.tutorialsteacher.com/python/magic-methods-in-python), ho·∫∑c [·ªü ƒë√¢y](https://docs.python.org/3/reference/datamodel.html#special-method-names) danh s√°ch ƒë·∫ßy ƒë·ªß c√°c magic method m√† Python h·ªó tr·ª£.

M·ªôt s·ªë magic method kh√°c c·∫ßn ch√∫ √Ω `__len__`, `__str__`, `__iter__`, and `__slots__` (tham kh·∫£o [ƒë√¢y](https://stackoverflow.com/questions/472000/usage-of-slots/28059785#28059785))

# 5. Local namespace, object's attributes

------------------------------------------------------------------------

H√†m `locals()` tr·∫£ v·ªÅ danh s√°ch c√°c bi·∫øn n·∫±m trong local namespace:

```{python}
class Model1:
    def __init__(self, hidden_size=100, num_layers=3, learning_rate=3e-4):
        print(locals())
        self.hidden_size = hidden_size
        self.num_layers = num_layers
        self.learning_rate = learning_rate

model1 = Model1()
```

C√°c attributes c·ªßa 1 object c≈©ng ƒë∆∞·ª£c l∆∞u h·∫øt trong `__dict__`:

```{python}
print(model1.__dict__)
```

Khi c√≥ qu√° nhi·ªÅu arguments, vi·ªác assign n√≥ trong `__init__` tr·ªü n√™n phi·ªÅn h√†, ch√∫ng ta c√≥ th·ªÉ l√†m nh∆∞ sau:

```{python}
class Model2:
    def __init__(self, hidden_size=100, num_layers=3, learning_rate=3e-4):
        params = locals()
        del params['self']
        self.__dict__ = params

model2 = Model2()
print(model2.__dict__)
```

Th·∫≠m ch√≠ r·∫•t ti·ªán khi l√†m vi·ªác v·ªõi `*kwargs`:

```{python}
class Model3:
    def __init__(self, **kwargs):
        self.__dict__ = kwargs

model3 = Model3(hidden_size=100, num_layers=3, learning_rate=3e-4)
print(model3.__dict__)
```

ƒê·ªçc th√™m v·ªÅ `*args` v√† `*kwargs` ·ªü [ƒë√¢y](https://manhhomienbienthuy.github.io/2019/09/20/python-args-kwargs.html).

# 6. Wild Import

------------------------------------------------------------------------

Ch√∫ng ta th∆∞·ªùng `import` t·∫•t c·∫£ nh∆∞ th·∫ø n√†y:

`file.py`

```{python}
#| eval: false
from parts import *
```

S·∫Ω l√† v√¥ tr√°ch nhi·ªám khi ch√∫ng ta import to√†n b·ªô module, v√≠ d·ª• n·∫øu `parts.py` c√≥ c·∫•u tr√∫c nh∆∞ th·∫ø n√†y: `parts.py`

```{python}
#| eval: false
import numpy 
import tensorflow 
class Encoder: 
    ... 
class Decoder: 
    ... 
class Loss: 
    ... 
def helper(*args, **kwargs): 
    ...
def utils(*args, **kwargs): 
    ... 
```

V√¨ `parts.py` kh√¥ng ƒë·ªãnh nghƒ©a `__all__`, n√™n `file.py` s·∫Ω import t·∫•t c·∫£ Encoder, Decoder, Loss, helper, untils c√πng v·ªõi numpy v√† tensorFlow. N·∫øu ch·ªâ mu·ªën import Encoder, Decoder, Loss, ch√∫ng ta n√™n l√†m nh∆∞ sau: `parts.py`

```{python}
#| eval: false
__all__ = ['Encoder', 'Decoder', 'Loss'] 
import numpy 
import tensorflow 
class Encoder: 
    ... 
```

Ch√∫ng ta c√≥ th·ªÉ d√πng `__all__` ƒë·ªÉ t√¨m hi·ªÉu th√†nh ph·∫ßn m·ªôt module.

# 7. Decorator to time your functions

------------------------------------------------------------------------

Ch√∫ng ta th∆∞·ªùng mu·ªën ƒëo l∆∞·ªùng th·ªùi gian ch·∫°y c·ªßa 1 function. C√°c t·ª± nhi√™n th∆∞·ªùng d√πng l√† ƒë·∫∑t `time.time()` ·ªü hai ƒëi·ªÉm ƒë·∫ßu v√† cu·ªëi gi·ªØa c√°c l·ªánh.

V√≠ d·ª•, v·ªõi h√†m t√¨m s·ªë Fibbonacci th·ª© n, v·ªõi hai c√°ch (1 c√°ch s·ª≠ d·ª•ng memoization).

```{python}
def fib_helper(n):
    if n < 2:
        return n
    return fib_helper(n - 1) + fib_helper(n - 2)

def fib(n):
    """ fib is a wrapper function so that later we can change its behavior
    at the top level without affecting the behavior at every recursion step.
    """
    return fib_helper(n)

def fib_m_helper(n, computed):
    if n in computed:
        return computed[n]
    computed[n] = fib_m_helper(n - 1, computed) + fib_m_helper(n - 2, computed)
    return computed[n]

def fib_m(n):
    return fib_m_helper(n, {0: 0, 1: 1})
```

H√£y ch·∫Øc ch·∫Øn `fib` v√† `fib_m` t∆∞∆°ng ƒë∆∞∆°ng nhau:

```{python}
for n in range(20):
    assert fib(n) == fib_m(n)
```

ƒêo l∆∞·ªùng th·ªùi gian ch·∫°y:

```{python}
import time

start = time.time()
fib(30)
print(f'Without memoization, it takes {time.time() - start:7f} seconds.')

start = time.time()
fib_m(30)
print(f'With memoization, it takes {time.time() - start:.7f} seconds.')
```
Using decorator, define `timeit`:
```{python}
def timeit(fn): 
    # *args and **kwargs are to support positional and named arguments of fn
    def get_time(*args, **kwargs): 
        start = time.time() 
        output = fn(*args, **kwargs)
        print(f"Time taken in {fn.__name__}: {time.time() - start:.7f}")
        return output  # make sure that the decorator returns the output of fn
    return get_time 
```
Sau ƒë√≥ th√™m `@timeit` t·ªõi function:
```{python}
@timeit
def fib(n):
    return fib_helper(n)

@timeit
def fib_m(n):
    return fib_m_helper(n, {0: 0, 1: 1})

fib(30)
fib_m(30)
```
# 8. Caching with `@functools.lru_cache`

------------------------------------------------------------------------

üöÄNguy√™n vƒÉn ch·ªã Huy·ªÅn:
> Memoization is a form of cache: we cache the previously calculated Fibonacci numbers so that we don't have to calculate them again.

```{python}
import functools

@functools.lru_cache()
def fib_helper(n):
    if n < 2:
        return n
    return fib_helper(n - 1) + fib_helper(n - 2)

@timeit
def fib(n):
    """ fib is a wrapper function so that later we can change its behavior
    at the top level without affecting the behavior at every recursion step.
    """
    return fib_helper(n)

fib(50)
fib_m(50)
```
`lru` stands for "least recently used". For more information on cache, see [here](https://docs.python.org/3/library/functools.html).

# Reference

------------------------------------------------------------------------

Source: <https://github.com/chiphuyen/python-is-cool/tree/master>