---
title: "Bitcoin tour in Python"
description: "NhÃ¢n viá»‡c thÃ¡nh Andrej Karpathy ra ~~MV~~ [tutorial má»›i](https://www.youtube.com/watch?v=l8pRSuU81PU&t=9160s) vá» build GPT-2 from scratch, tÃ´i láº¡i ghÃ© thÄƒm trang web cÃ¡ nhÃ¢n cá»§a anh áº¥y."
author:
  - name: "Tuan Le Khac"
    url: https://lktuan.github.io/
date: 06-10-2024
date-modified: 06-20-2024
categories: [til, crypto, bitcoin, python, andrej karpathy] 
image: python_bitcoin.png
draft: false
css: html/styles.scss
fig-cap-location: bottom
editor: visual
code-fold: show
---

A from-scratch implementation of Bitcoin in Python under tuturial from Andrej Karpathy. 

# Motivation

ÄÃ¢y lÃ  bÃ i thá»±c hÃ nh implement Bitcoin sá»­ dá»¥ng Python mÃ  tÃ´i há»c Ä‘Æ°á»£c trÃªn trang blog cá»§a Andrej Karpathy, nhÃ  Khoa há»c mÃ¡y tÃ­nh, cá»±u Director máº£ng AI cá»§a Open AI.

[Andrej Karpathy](https://karpathy.ai/) cho ráº±ng blockchain Ä‘ang giÃºp ná»›i rá»™ng tráº¡ng thÃ¡i cá»§a ngÃ nh cÃ´ng nghiá»‡p phÃ¡t triá»ƒn pháº§n má»m, tá»« open source thÃ nh open source plus. NghÄ©a lÃ  chÃºng ta Ä‘ang khÃ´ng chá»‰ chia sáº», cÃ´ng khai mÃ£ nguá»“n, mÃ  cÃ²n cáº£ tÃ i nguyÃªn (run time, computing machine). VÃ  vá»›i tinh tháº§n:

> "what I cannot create I do not understand"

, cÃ¡ch tá»‘t nháº¥t Ä‘á»ƒ há»c nÃ³ lÃ  thá»±c hiá»‡n nÃ³. TÃ´i cÅ©ng cho lÃ  tháº¿!

::: {layout-ncol=1}
![Andrej Karpathy trong podcast vá»›i Lex Fridman](karpathy-podcast.jpg){width=100%}
:::

Pháº¡m vi bÃ i thá»±c hÃ nh nÃ y lÃ  **táº¡o, kÃ½ sá»‘, phÃ¡t hÃ nh cÃ¡c giao dá»‹ch Bitcoin thuáº§n Python, tá»« con sá»‘ 0, khÃ´ng thÆ° viá»‡n phá»¥ thuá»™c**.

ÄÃ¢y lÃ  mÃ´i trÆ°á»ng Python cá»§a mÃ¬nh:
```{python}
#| code-fold: true
import sys
print(sys.version)
```

# Step 1: generating a crypto identity

Má»™t trong nhá»¯ng Ä‘áº·c tÃ­nh quan trá»ng nháº¥t cá»§a Bitcoin nÃ³i riÃªng vÃ  Blockchain (chuá»—i khá»‘i) nÃ³i chung lÃ  tÃ­nh báº£o máº­t. Blockchain sá»­ dá»¥ng cÃ¡c phÆ°Æ¡ng thá»©c báº£o máº­t nhÆ°: **ECC**, **ECDH** hoáº·c **ECDSA**, trong Ä‘Ã³ `EC` chÃ­nh lÃ  viáº¿t táº¯t cá»§a Elliptic Curve. KhÃ´ng chá»‰ trong lÄ©nh vá»±c blockchain, `EC` cÃ²n Ä‘Æ°á»£c sá»­ dá»¥ng rá»™ng rÃ£i trong báº£o máº­t [`TLS`](https://datatracker.ietf.org/doc/html/rfc4492), [`PGP`](https://datatracker.ietf.org/doc/html/rfc6637), [`SSH`](https://datatracker.ietf.org/doc/html/rfc5656). 

KhÃ¡c vá»›i cÃ¡c báº£o máº­t **Ä‘á»‘i xá»©ng** thÃ´ng thÆ°á»ng, ta cÃ³ má»™t key duy nháº¥t Ä‘á»ƒ mÃ£ hÃ³a vÃ  giáº£i mÃ£ ~ cÃ³ key lÃ  cÃ³ táº¥t cáº£, khÃ´ng cÃ³ key lÃ  khÃ´ng cÃ³ gÃ¬, cÃ¡c thuáº­t toÃ¡n mÃ£ hÃ³a EC lÃ  **Báº¥t Ä‘á»‘i xá»©ng**. Trong Ä‘Ã³, ta cÃ³ má»™t cáº·p `private key`/`public key` (khÃ³a bÃ­ máº­t vÃ  khÃ³a cÃ´ng khai). KhÃ³a bÃ­ máº­t chá»‰ lÃ  má»™t con sá»‘ ngáº«u nhiÃªn, cáº§n Ä‘Æ°á»£c chá»§ nhÃ¢n cá»§a nÃ³ **giá»¯ bÃ­ máº­t hoÃ n toÃ n**, vÃ­ nÃ³ lÃ  thá»© duy nháº¥t táº¡o ra Ä‘Æ°á»£c **chá»¯ kÃ­** cho há». KhÃ¡c vá»›i khÃ³a bÃ­ máº­t, khÃ³a cÃ´ng khai Ä‘Æ°á»£c cÃ´ng khai cho táº¥t cáº£ má»i ngÆ°á»i. `public key` Ä‘Æ°á»£c táº¡o ra bá»Ÿi **phÃ©p nhÃ¢n** vá»›i `private key` trong **Ä‘Æ°á»ng cong Elliptic**. PhÃ©p nhÃ¢n Ä‘Æ°á»ng cong Elliptic lÃ  má»™t phÃ©p toÃ¡n **trap door** (cá»­a láº­t), cÃ³ nghÄ©a lÃ  nÃ³ dá»… tÃ­nh theo **má»™t chiá»u** (phÃ©p nhÃ¢n) vÃ  khÃ´ng thá»ƒ tÃ­nh Ä‘Æ°á»£c theo chiá»u ngÆ°á»£c láº¡i (phÃ©p chia) ~ Ä‘Ã³ lÃ  lÃ½ do ta gá»i nÃ³ lÃ  mÃ£ hÃ³a báº¥t Ä‘á»‘i xá»©ng.

Bitcoin sá»­ dá»¥ng Há»‡ máº­t trÃªn Ä‘Æ°á»ng cong Elliptic (ECC) Ä‘á»ƒ báº£o máº­t giao dá»‹ch [Xem thÃªm: 1. [Viblo](https://viblo.asia/p/gioi-thieu-ve-he-mat-tren-duong-cong-elliptic-ecc-XL6lA2PR5ek), 2. [Wiki](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography), 3. [Wolfram](https://mathworld.wolfram.com/EllipticCurve.html), quÃ¡ khÃ³ cho tÃ´i táº¡i thá»i Ä‘iá»ƒm bÃ¢y giá» - nÃªn tÃ´i sáº½ táº¡m bá» qua, dÃ¹ gÃ¬ cÅ©ng cáº§n phÃ¡c tháº£o má»™t khung tranh "má» má»" trÆ°á»›c, viá»‡c váº½ chi tiáº¿t Ä‘á»ƒ sau.]{.aside}.

ÄÆ°á»ng cong $E: y^2 = x^3 + ax + b \:(mod\:p)$ trÃªn trÆ°á»ng há»¯u háº¡n $Z_p$ (cÅ©ng cÃ³ ngÆ°á»i gá»i lÃ  $Z/p$,$GF_(p)$,hoáº·c $F_p$, vá»›i p lÃ  sá»‘ nguyÃªn tá»‘) Ä‘Æ°á»£c xÃ¡c Ä‘á»‹nh bá»Ÿi 6 tham sá»‘ $T = (p,a,b,G,n,h)$ sau:

- $p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F$

    $= 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1$

    $= 2^{256} - 2^{32} - 977$

-  $a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000$
-  $b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007$

VÃ¬ Ä‘Æ°á»£c xÃ¡c Ä‘á»‹nh trÃªn $Z_p$, nÃªn trÃªn thá»±c táº¿ nÃ³ lÃ  má»™t Ä‘Æ°á»ng khÃ´ng liÃªn lá»¥c, vÃ  trÃ´ng sáº½ nhÆ° cÃ¡c Ä‘iá»ƒm ngáº«u nhiÃªn trÃªn má»™t biá»ƒu Ä‘á»“ phÃ¢n tÃ¡n. Äá»ƒ dá»… tÆ°á»Ÿng tÆ°á»£ng vÃ  min há»a, khi xÃ¡c Ä‘á»‹nh trÃªn trÆ°á»ng sá»‘ thá»±c, EC sáº½ trÃ´ng nhÆ° tháº¿ nÃ y:

::: {layout-ncol=1}
![[What does the curve used in Bitcoin, secp256k1, look like?](https://bitcoin.stackexchange.com/questions/21907/what-does-the-curve-used-in-bitcoin-secp256k1-look-like)](what_does_ec_look_like.png){width=100%}
:::

ÄÃ¢y lÃ  tÃ i liá»‡u mÃ  Andrej gá»£i Ã½ cho chÃºng ta Ä‘á»c vá» ECC: [blog post](https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/) cá»§a Andrea Corbellini. BÃ i viáº¿t Ä‘áº§u tiÃªn cá»§a Ã´ng giá»›i thiá»‡u EC trÃªn **trÆ°á»ng sá»‘ thá»±c vÃ  luáº­t nhÃ³m**. Theo Ä‘Ã³, vá»›i EC Ä‘Æ°á»£c xÃ¡c Ä‘á»‹nh báº±ng $\{(x,y)\in R^2 | y^2 = x^3 + ax + b, 4a^3 + 27b^2 \neq 0\} \cup \{0\}$ ($4a^3 + 27b^2 \neq 0$ lÃ  Ä‘á»ƒ trÃ¡nh Ä‘iá»ƒm ká»³ dá»‹ singular), cÃ¹ng vá»›i cÃ¡c tiÃªn Ä‘á» vá» phÃ©p toÃ¡n cá»™ng ($+$) Ä‘Æ°á»£c trang bá»‹ gá»“m:

1. TÃ­nh Ä‘Ã³ng (closure): náº¿u $a$ vÃ  $b$ thuá»™c $G$, thÃ¬ $a+b$ cÅ©ng thuá»™c $G$;
2. TÃ­nh káº¿t há»£p (associativity): $(a+b)+c = a + (b+c)$;
3. Sá»± tá»“n táº¡i cá»§a pháº§n tá»­ Ä‘Æ¡n vá»‹ (identity element 0): $a+0=0+a=a$;
4. TÃ­nh kháº£ nghá»‹ch (commutativity): vá»›i má»i $a$, tá»“n táº¡i $b$ sao cho $a+b=0$;

Náº¿u chÃºng ta cÃ³ thÃªm tÃ­nh cháº¥t thá»© 5 sau:

5. TÃ­nh giao hoÃ¡n (commutativity): $a+b = b+a$.

ThÃ¬ nhÃ³m Ä‘Ã³ Ä‘Æ°á»£c xem lÃ  má»™t nhÃ³m Abel (VÃ­ dá»¥: táº­p há»£p cÃ¡c sá»‘ nguyÃªn $Z$ lÃ  má»™t nhÃ³m - Abel).

Táº­p há»£p cÃ¡c Ä‘iá»ƒm trÃªn EC lÃ  má»™t nhÃ³m Abel, do Ä‘Ã³ nÃ³ cÅ©ng cÃ³ tÃ­nh cháº¥t trÃªn: cÃ³ sá»± tá»“n táº¡i cá»§a **pháº§n tá»­ Ä‘Æ¡n vá»‹** 0 (cÅ©ng lÃ  vÃ´ háº¡n); pháº§n tá»­ **nghá»‹ch Ä‘áº£o** cá»§a $P$, kÃ½ hiá»‡u $-P$, lÃ  Ä‘iá»ƒm Ä‘á»‘i xá»©ng cá»§a P qua trá»¥c hoÃ nh; **phÃ©p cá»™ng** Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a nhÆ° sau: vá»›i ba Ä‘iá»ƒm $P$, $Q$, $R$ khÃ¡c 0 vÃ  tháº³ng hÃ ng trÃªn EC, thÃ¬ $P + Q + R = 0$, báº¥t ká»ƒ thá»© tá»± cá»§a cÃ¡c Ä‘iá»ƒm - ta tháº¥y nÃ³ thá»a mÃ£n cÃ¡c tÃ­nh cháº¥t káº¿t há»£p vÃ  giao hoÃ¡n cá»§a má»™t nhÃ³m Abel!.

**PhÃ©p cá»™ng hÃ¬nh há»c vÃ  Ä‘áº¡i sá»‘** vÃ  **phÃ©p nhÃ¢n vÃ´ hÆ°á»›ng** sáº½ Ä‘Æ°á»£c trÃ¬nh bÃ y á»Ÿ phÃ­a sau - trá»±c tiáº¿p trong khÃ´ng gian há»¯u háº¡n. Hiá»‡n táº¡i Ã¬nh chá»‰ cá»‘ gáº¯ng **hÃ¬nh dung** cÃ¡c tÃ­nh cháº¥t cá»§a EC thÃ´ng qua viá»‡c xem xÃ©t nÃ³ trÃªn **trÆ°á»ng sá»‘ thá»±c**.

Block code dÆ°á»›i Ä‘Ã¢y Ä‘á»‹nh nghÄ©a Ä‘Æ°á»ng cong EC. Bitcoin (hay Ethereum) sá»­ dá»¥ng má»™t Ä‘Æ°á»ng cong theo tiÃªu chuáº©n [secp256k1](https://en.bitcoin.it/wiki/Secp256k1) do *Viá»‡n TiÃªu Chuáº©n vÃ  Ká»¹ Thuáº­t Quá»‘c Gia Má»¹ (NIST)* Ä‘áº·t ra. Vá»›i $a=0$, $b=7$, Ä‘á»‹nh nghÄ©a Ä‘Æ°á»ng cong trÃªn trÆ°á»ng $Z_p$ giá» sáº½ lÃ :

$\{(x,y)\in (Z_p)^2 |\: y^2 \equiv x^3 + 7 \: (mod \: p)\} \cup \{0\}$

```{python}
# from __future__ import annotations # PEP 563: Postponed evaluation of annotations
# since my python version is 3.11.4 so no need to use future annotation feature 
# which redefined since python 3.5
from dataclasses import dataclass # replace constructor __init__, 
# help us to easily declare class attributes.

@dataclass
class Curve:
    """
    Elliptic Curve over the field of integers modulo a prime.
    Points on the curve satisfy y^2 = x^3 + a*x + b (mod p).

    Z_p lÃ  má»™t Táº¬P Há»¢P, khi p lÃ  sá»‘ nguyÃªn tá»‘ thÃ¬ cÃ³ thá»ƒ coi nÃ³ lÃ  má»™t TRÆ¯á»œNG 
    https://forum.mathscope.org/archive/index.php/t-11835.html
    """
    p: int # ta nÃ³i secp256k1 cÃ³ Ä‘áº·c trÆ°ng p, Ä‘Æ°á»£c Ä‘á»‹nh trong trÆ°á»ng Z_p
    a: int
    b: int

# secp256k1 uses a = 0, b = 7, so we're dealing with the curve y^2 = x^3 + 7 (mod p)
bitcoin_curve = Curve(
    p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F,
    a = 0x0000000000000000000000000000000000000000000000000000000000000000, # a = 0
    b = 0x0000000000000000000000000000000000000000000000000000000000000007, # b = 7
)
```

ChÃºng ta chÆ°a tháº¥y phÆ°Æ¡ng trÃ¬nh cá»§a EC Ä‘Æ°á»£c thá»ƒ hiá»‡n trong class `Curve`, chÃºng ta implement nÃ³ báº±ng cÃ¡ch táº¡o má»™t class `Point`.
Sau khi xÃ¡c Ä‘á»‹nh curve, ta xÃ¡c Ä‘á»‹nh generator (lÃ  má»™t Ä‘iá»ƒm dÃ¹ng Ä‘á»ƒ khá»Ÿi táº¡o quÃ¡ trÃ¬nh "walk" trÃªn Ä‘Æ°á»ng cong)

```{python}
@dataclass
class Point:
    """ Sá»‘ nguyÃªn tá»a Ä‘á»™ (x,y) trÃªn Ä‘Æ°á»ng cong """
    curve: Curve
    x: int
    y: int

G = Point(
    bitcoin_curve,
    x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
    y = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,    
)

# xÃ¡c nháº­n xem G cÃ³ náº±m trÃªn Ä‘Æ°á»ng cong hay khÃ´ng, tá»©c lÃ  y^2 = x^3 + 7 (mod p)
print("G is on the curve:", (G.y**2 - G.x**3 - 7) % bitcoin_curve.p == 0)

# cÃ¡c giÃ¡ trá»‹ báº¥t ká»³ khÃ¡c Háº¦U NHÆ¯ sáº½ khÃ´ng náº±m trÃªn Ä‘Æ°á»ng cong:
import random
random.seed(1337)
x = random.randrange(0, bitcoin_curve.p) # ngáº«u nhiÃªn giá»¯a 0 vÃ  p
y = random.randrange(0, bitcoin_curve.p)
print("G is on the curve:", (y**2 - x**3 - 7) % bitcoin_curve.p == 0)
```

Some notes to be updated here

```{python}
@dataclass
class Generator:
    """
    A Generator over a curve: an initial point and pre-declared order.
    """
    G: Point # starting point on the curve
    n: int # the order 0*G = n*G = INF (????)

bitcoin_gen = Generator(
    G = G,
    # the order of G is known and can be mathematically derived
    n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,
)

```

NhÆ° váº­y Ä‘Ã£ Ä‘á»‹nh nghÄ©a xong ÄÆ°á»ng Cong, Äiá»ƒm sinh (`G`), vÃ  TrÃ¬nh táº¡o. Giá» ta sáº½ táº¡o `private key` (hay `secret key`) - má»™t sá»‘ nguyÃªn ngáº«u nhiÃªn thá»a `1<= key < n` (n Ä‘áº¡i diá»‡n cho order).

```{python}
secret_key = int.from_bytes(b'Hi, this is Tuan', 'big') # this is how I will do it for reproducibility
assert 1 <= secret_key < bitcoin_gen.n
print(secret_key)
```

Giá» chÃºng ta sáº½ táº¡o `public key`, chá»‰nh lÃ  cá»™ng `G` `private key` láº§n.

```{python}
INF = Point(None, None, None) # special point at "infinity", kind of like a zero

def extended_euclidean_algorithm(a, b):
    """
    Returns (gcd, x, y) s.t. a * x + b * y == gcd
    This function implements the extended Euclidean
    algorithm and runs in O(log b) in the worst case,
    taken from Wikipedia.
    """
    old_r, r = a, b
    old_s, s = 1, 0
    old_t, t = 0, 1
    while r != 0:
        quotient = old_r // r
        old_r, r = r, old_r - quotient * r
        old_s, s = s, old_s - quotient * s
        old_t, t = t, old_t - quotient * t
    return old_r, old_s, old_t

def inv(n, p):
    """ returns modular multiplicate inverse m s.t. (n * m) % p == 1 """
    gcd, x, y = extended_euclidean_algorithm(n, p) # pylint: disable=unused-variable
    return x % p

def elliptic_curve_addition(self, other: Point) -> Point:
    # handle special case of P + 0 = 0 + P = 0
    if self == INF:
        return other
    if other == INF:
        return self
    # handle special case of P + (-P) = 0
    if self.x == other.x and self.y != other.y:
        return INF
    # compute the "slope"
    if self.x == other.x: # (self.y = other.y is guaranteed too per above check)
        m = (3 * self.x**2 + self.curve.a) * inv(2 * self.y, self.curve.p)
    else:
        m = (self.y - other.y) * inv(self.x - other.x, self.curve.p)
    # compute the new point
    rx = (m**2 - self.x - other.x) % self.curve.p
    ry = (-(m*(rx - self.x) + self.y)) % self.curve.p
    return Point(self.curve, rx, ry)

Point.__add__ = elliptic_curve_addition # monkey patch addition into the Point class
```

Giá» ta sáº½ thá»­ gen má»™t sá»‘ bá»™ `private key`, `public key`:

```{python}
# if our secret key was the integer 1, then our public key would just be G:
# use sk for secret key = private key
sk = 1
pk = G
print(f" secret key: {sk}\n public key: {(pk.x, pk.y)}")
print("Verify the public key is on the curve: ", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)
# if it was 2, the public key is G + G:
sk = 2
pk = G + G
print(f" secret key: {sk}\n public key: {(pk.x, pk.y)}")
print("Verify the public key is on the curve: ", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)
# etc.:
sk = 3
pk = G + G + G
print(f" secret key: {sk}\n public key: {(pk.x, pk.y)}")
print("Verify the public key is on the curve: ", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)
```

ChÃºng ta cáº§n tÄƒng tá»‘c viá»‡c cá»™ng `G` vá»›i chÃ­nh nÃ³ vá»›i sá»‘ láº§n cá»±c kÃ¬ lá»›n, do Ä‘Ã³ Andrej sá»­ dá»¥ng 1 thuáº­t toÃ¡n `double_and_add` nhÆ° sau:

```{python}
def double_and_add(self, k: int) -> Point:
    assert isinstance(k, int) and k >= 0
    result = INF
    append = self
    while k:
        if k & 1:
            result += append
        append += append
        k >>= 1
    return result

# monkey patch double and add into the Point class for convenience
Point.__rmul__ = double_and_add

# "verify" correctness
print(G == 1*G)
print(G + G == 2*G)
print(G + G + G == 3*G)
```

Giá» test vá»›i `private_key` mÃ  chÃºng ta táº¡o lÃºc Ä‘áº§u:

```{python}
# efficiently calculate our actual public key!
public_key = secret_key * G
print(f"x: {public_key.x}\ny: {public_key.y}")
print("Verify the public key is on the curve: ", (public_key.y**2 - public_key.x**3 - 7) % bitcoin_curve.p == 0)
```

**ğŸš€ÄÃ£ Ä‘Æ°á»£c modulized á»Ÿ** [`curves.py`]()

Vá»›i cáº·p private/public key ta Ä‘Ã£ implement Ä‘Æ°á»£c kháº£ nÄƒng Ä‘á»‹nh danh cho Bitcoin. Giá» ta cáº§n liÃªn káº¿t nÃ³ vá»›i Ä‘á»‹a chá»‰ vÃ­. TrÆ°á»›c háº¿t ta cáº§n triá»ƒn khai má»™t sá»‘ hÃ m hash.

CÃ³ thá»ƒ sá»­ dá»¥ng `hashlib` cá»§a Python tuy nhiÃªn Andrej khÃ´ng muá»‘n sá»­ dá»¥ng thÆ° viá»‡n phá»¥ thuá»™c. Andrej Ä‘Ã£ viáº¿t láº¡i hai hÃ m hash mÃ  Bitcoin sá»­ dá»¥ng lÃ  `SHA-256` vÃ  `RIPEMD-160`, láº§n lÆ°á»£t dÆ°á»›i Ä‘Ã¢y, mÃ¬nh note giáº£i thÃ­ch cá»§a Andrej á»Ÿ pháº§n code comment.

CÃ³ láº½ sáº½ cáº§n má»™t dá»‹p khÃ¡c Ä‘á»ƒ hiá»ƒu hai hÃ m bÄƒm nÃ y, nÃ³ náº±m ngoÃ i kháº£ nÄƒng cá»§a mÃ¬nh.

```{python}
#| code-fold: true
def gen_sha256_with_variable_scope_protector_to_not_pollute_global_namespace():

    """
    SHA256 implementation.

    Follows the FIPS PUB 180-4 description for calculating SHA-256 hash function
    https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf

    Noone in their right mind should use this for any serious reason. This was written
    purely for educational purposes.
    """

    import math
    from itertools import count, islice

    # -----------------------------------------------------------------------------
    # SHA-256 Functions, defined in Section 4

    def rotr(x, n, size=32):
        return (x >> n) | (x << size - n) & (2**size - 1)

    def shr(x, n):
        return x >> n

    def sig0(x):
        return rotr(x, 7) ^ rotr(x, 18) ^ shr(x, 3)

    def sig1(x):
        return rotr(x, 17) ^ rotr(x, 19) ^ shr(x, 10)

    def capsig0(x):
        return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)

    def capsig1(x):
        return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)

    def ch(x, y, z):
        return (x & y)^ (~x & z)

    def maj(x, y, z):
        return (x & y) ^ (x & z) ^ (y & z)

    def b2i(b):
        return int.from_bytes(b, 'big')

    def i2b(i):
        return i.to_bytes(4, 'big')

    # -----------------------------------------------------------------------------
    # SHA-256 Constants

    def is_prime(n):
        return not any(f for f in range(2,int(math.sqrt(n))+1) if n%f == 0)

    def first_n_primes(n):
        return islice(filter(is_prime, count(start=2)), n)

    def frac_bin(f, n=32):
        """ return the first n bits of fractional part of float f """
        f -= math.floor(f) # get only the fractional part
        f *= 2**n # shift left
        f = int(f) # truncate the rest of the fractional content
        return f

    def genK():
        """
        Follows Section 4.2.2 to generate K

        The first 32 bits of the fractional parts of the cube roots of the first
        64 prime numbers:

        428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5
        d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174
        e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da
        983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967
        27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85
        a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070
        19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
        748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2
        """
        return [frac_bin(p ** (1/3.0)) for p in first_n_primes(64)]

    def genH():
        """
        Follows Section 5.3.3 to generate the initial hash value H^0

        The first 32 bits of the fractional parts of the square roots of
        the first 8 prime numbers.

        6a09e667 bb67ae85 3c6ef372 a54ff53a 9b05688c 510e527f 1f83d9ab 5be0cd19
        """
        return [frac_bin(p ** (1/2.0)) for p in first_n_primes(8)]

    # -----------------------------------------------------------------------------

    def pad(b):
        """ Follows Section 5.1: Padding the message """
        b = bytearray(b) # convert to a mutable equivalent
        l = len(b) * 8 # note: len returns number of bytes not bits

        # append but "1" to the end of the message
        b.append(0b10000000) # appending 10000000 in binary (=128 in decimal)

        # follow by k zero bits, where k is the smallest non-negative solution to
        # l + 1 + k = 448 mod 512
        # i.e. pad with zeros until we reach 448 (mod 512)
        while (len(b)*8) % 512 != 448:
            b.append(0x00)

        # the last 64-bit block is the length l of the original message
        # expressed in binary (big endian)
        b.extend(l.to_bytes(8, 'big'))

        return b

    def sha256(b: bytes) -> bytes:

        # Section 4.2
        K = genK()

        # Section 5: Preprocessing
        # Section 5.1: Pad the message
        b = pad(b)
        # Section 5.2: Separate the message into blocks of 512 bits (64 bytes)
        blocks = [b[i:i+64] for i in range(0, len(b), 64)]

        # for each message block M^1 ... M^N
        H = genH() # Section 5.3

        # Section 6
        for M in blocks: # each block is a 64-entry array of 8-bit bytes

            # 1. Prepare the message schedule, a 64-entry array of 32-bit words
            W = []
            for t in range(64):
                if t <= 15:
                    # the first 16 words are just a copy of the block
                    W.append(bytes(M[t*4:t*4+4]))
                else:
                    term1 = sig1(b2i(W[t-2]))
                    term2 = b2i(W[t-7])
                    term3 = sig0(b2i(W[t-15]))
                    term4 = b2i(W[t-16])
                    total = (term1 + term2 + term3 + term4) % 2**32
                    W.append(i2b(total))

            # 2. Initialize the 8 working variables a,b,c,d,e,f,g,h with prev hash value
            a, b, c, d, e, f, g, h = H

            # 3.
            for t in range(64):
                T1 = (h + capsig1(e) + ch(e, f, g) + K[t] + b2i(W[t])) % 2**32
                T2 = (capsig0(a) + maj(a, b, c)) % 2**32
                h = g
                g = f
                f = e
                e = (d + T1) % 2**32
                d = c
                c = b
                b = a
                a = (T1 + T2) % 2**32

            # 4. Compute the i-th intermediate hash value H^i
            delta = [a, b, c, d, e, f, g, h]
            H = [(i1 + i2) % 2**32 for i1, i2 in zip(H, delta)]

        return b''.join(i2b(i) for i in H)

    return sha256

sha256 = gen_sha256_with_variable_scope_protector_to_not_pollute_global_namespace()
print("verify empty hash:", sha256(b'').hex()) # should be e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
print(sha256(b'here is a random bytes message, cool right?').hex())
print("number of bytes in a sha256 digest: ", len(sha256(b'')))
```

HÃ m bÄƒm thá»© hai lÃ  `RIPEMD-160`:

```{python}
#| code-fold: true
def gen_ripemd160_with_variable_scope_protector_to_not_pollute_global_namespace():

    import sys
    import struct

    # -----------------------------------------------------------------------------
    # public interface

    def ripemd160(b: bytes) -> bytes:
        """ simple wrapper for a simpler API to this hash function, just bytes to bytes """
        ctx = RMDContext()
        RMD160Update(ctx, b, len(b))
        digest = RMD160Final(ctx)
        return digest

    # -----------------------------------------------------------------------------

    class RMDContext:
        def __init__(self):
            self.state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0] # uint32
            self.count = 0 # uint64
            self.buffer = [0]*64 # uchar

    def RMD160Update(ctx, inp, inplen):
        have = int((ctx.count // 8) % 64)
        inplen = int(inplen)
        need = 64 - have
        ctx.count += 8 * inplen
        off = 0
        if inplen >= need:
            if have:
                for i in range(need):
                    ctx.buffer[have+i] = inp[i]
                RMD160Transform(ctx.state, ctx.buffer)
                off = need
                have = 0
            while off + 64 <= inplen:
                RMD160Transform(ctx.state, inp[off:])
                off += 64
        if off < inplen:
            for i in range(inplen - off):
                ctx.buffer[have+i] = inp[off+i]

    def RMD160Final(ctx):
        size = struct.pack("<Q", ctx.count)
        padlen = 64 - ((ctx.count // 8) % 64)
        if padlen < 1 + 8:
            padlen += 64
        RMD160Update(ctx, PADDING, padlen-8)
        RMD160Update(ctx, size, 8)
        return struct.pack("<5L", *ctx.state)

    # -----------------------------------------------------------------------------

    K0 = 0x00000000
    K1 = 0x5A827999
    K2 = 0x6ED9EBA1
    K3 = 0x8F1BBCDC
    K4 = 0xA953FD4E
    KK0 = 0x50A28BE6
    KK1 = 0x5C4DD124
    KK2 = 0x6D703EF3
    KK3 = 0x7A6D76E9
    KK4 = 0x00000000

    PADDING = [0x80] + [0]*63

    def ROL(n, x):
        return ((x << n) & 0xffffffff) | (x >> (32 - n))

    def F0(x, y, z):
        return x ^ y ^ z

    def F1(x, y, z):
        return (x & y) | (((~x) % 0x100000000) & z)

    def F2(x, y, z):
        return (x | ((~y) % 0x100000000)) ^ z

    def F3(x, y, z):
        return (x & z) | (((~z) % 0x100000000) & y)

    def F4(x, y, z):
        return x ^ (y | ((~z) % 0x100000000))

    def R(a, b, c, d, e, Fj, Kj, sj, rj, X):
        a = ROL(sj, (a + Fj(b, c, d) + X[rj] + Kj) % 0x100000000) + e
        c = ROL(10, c)
        return a % 0x100000000, c

    def RMD160Transform(state, block): #uint32 state[5], uchar block[64]

        x = [0]*16
        assert sys.byteorder == 'little', "Only little endian is supported atm for RIPEMD160"
        x = struct.unpack('<16L', bytes(block[0:64]))

        a = state[0]
        b = state[1]
        c = state[2]
        d = state[3]
        e = state[4]

        #/* Round 1 */
        a, c = R(a, b, c, d, e, F0, K0, 11,  0, x)
        e, b = R(e, a, b, c, d, F0, K0, 14,  1, x)
        d, a = R(d, e, a, b, c, F0, K0, 15,  2, x)
        c, e = R(c, d, e, a, b, F0, K0, 12,  3, x)
        b, d = R(b, c, d, e, a, F0, K0,  5,  4, x)
        a, c = R(a, b, c, d, e, F0, K0,  8,  5, x)
        e, b = R(e, a, b, c, d, F0, K0,  7,  6, x)
        d, a = R(d, e, a, b, c, F0, K0,  9,  7, x)
        c, e = R(c, d, e, a, b, F0, K0, 11,  8, x)
        b, d = R(b, c, d, e, a, F0, K0, 13,  9, x)
        a, c = R(a, b, c, d, e, F0, K0, 14, 10, x)
        e, b = R(e, a, b, c, d, F0, K0, 15, 11, x)
        d, a = R(d, e, a, b, c, F0, K0,  6, 12, x)
        c, e = R(c, d, e, a, b, F0, K0,  7, 13, x)
        b, d = R(b, c, d, e, a, F0, K0,  9, 14, x)
        a, c = R(a, b, c, d, e, F0, K0,  8, 15, x) #/* #15 */
        #/* Round 2 */
        e, b = R(e, a, b, c, d, F1, K1,  7,  7, x)
        d, a = R(d, e, a, b, c, F1, K1,  6,  4, x)
        c, e = R(c, d, e, a, b, F1, K1,  8, 13, x)
        b, d = R(b, c, d, e, a, F1, K1, 13,  1, x)
        a, c = R(a, b, c, d, e, F1, K1, 11, 10, x)
        e, b = R(e, a, b, c, d, F1, K1,  9,  6, x)
        d, a = R(d, e, a, b, c, F1, K1,  7, 15, x)
        c, e = R(c, d, e, a, b, F1, K1, 15,  3, x)
        b, d = R(b, c, d, e, a, F1, K1,  7, 12, x)
        a, c = R(a, b, c, d, e, F1, K1, 12,  0, x)
        e, b = R(e, a, b, c, d, F1, K1, 15,  9, x)
        d, a = R(d, e, a, b, c, F1, K1,  9,  5, x)
        c, e = R(c, d, e, a, b, F1, K1, 11,  2, x)
        b, d = R(b, c, d, e, a, F1, K1,  7, 14, x)
        a, c = R(a, b, c, d, e, F1, K1, 13, 11, x)
        e, b = R(e, a, b, c, d, F1, K1, 12,  8, x) #/* #31 */
        #/* Round 3 */
        d, a = R(d, e, a, b, c, F2, K2, 11,  3, x)
        c, e = R(c, d, e, a, b, F2, K2, 13, 10, x)
        b, d = R(b, c, d, e, a, F2, K2,  6, 14, x)
        a, c = R(a, b, c, d, e, F2, K2,  7,  4, x)
        e, b = R(e, a, b, c, d, F2, K2, 14,  9, x)
        d, a = R(d, e, a, b, c, F2, K2,  9, 15, x)
        c, e = R(c, d, e, a, b, F2, K2, 13,  8, x)
        b, d = R(b, c, d, e, a, F2, K2, 15,  1, x)
        a, c = R(a, b, c, d, e, F2, K2, 14,  2, x)
        e, b = R(e, a, b, c, d, F2, K2,  8,  7, x)
        d, a = R(d, e, a, b, c, F2, K2, 13,  0, x)
        c, e = R(c, d, e, a, b, F2, K2,  6,  6, x)
        b, d = R(b, c, d, e, a, F2, K2,  5, 13, x)
        a, c = R(a, b, c, d, e, F2, K2, 12, 11, x)
        e, b = R(e, a, b, c, d, F2, K2,  7,  5, x)
        d, a = R(d, e, a, b, c, F2, K2,  5, 12, x) #/* #47 */
        #/* Round 4 */
        c, e = R(c, d, e, a, b, F3, K3, 11,  1, x)
        b, d = R(b, c, d, e, a, F3, K3, 12,  9, x)
        a, c = R(a, b, c, d, e, F3, K3, 14, 11, x)
        e, b = R(e, a, b, c, d, F3, K3, 15, 10, x)
        d, a = R(d, e, a, b, c, F3, K3, 14,  0, x)
        c, e = R(c, d, e, a, b, F3, K3, 15,  8, x)
        b, d = R(b, c, d, e, a, F3, K3,  9, 12, x)
        a, c = R(a, b, c, d, e, F3, K3,  8,  4, x)
        e, b = R(e, a, b, c, d, F3, K3,  9, 13, x)
        d, a = R(d, e, a, b, c, F3, K3, 14,  3, x)
        c, e = R(c, d, e, a, b, F3, K3,  5,  7, x)
        b, d = R(b, c, d, e, a, F3, K3,  6, 15, x)
        a, c = R(a, b, c, d, e, F3, K3,  8, 14, x)
        e, b = R(e, a, b, c, d, F3, K3,  6,  5, x)
        d, a = R(d, e, a, b, c, F3, K3,  5,  6, x)
        c, e = R(c, d, e, a, b, F3, K3, 12,  2, x) #/* #63 */
        #/* Round 5 */
        b, d = R(b, c, d, e, a, F4, K4,  9,  4, x)
        a, c = R(a, b, c, d, e, F4, K4, 15,  0, x)
        e, b = R(e, a, b, c, d, F4, K4,  5,  5, x)
        d, a = R(d, e, a, b, c, F4, K4, 11,  9, x)
        c, e = R(c, d, e, a, b, F4, K4,  6,  7, x)
        b, d = R(b, c, d, e, a, F4, K4,  8, 12, x)
        a, c = R(a, b, c, d, e, F4, K4, 13,  2, x)
        e, b = R(e, a, b, c, d, F4, K4, 12, 10, x)
        d, a = R(d, e, a, b, c, F4, K4,  5, 14, x)
        c, e = R(c, d, e, a, b, F4, K4, 12,  1, x)
        b, d = R(b, c, d, e, a, F4, K4, 13,  3, x)
        a, c = R(a, b, c, d, e, F4, K4, 14,  8, x)
        e, b = R(e, a, b, c, d, F4, K4, 11, 11, x)
        d, a = R(d, e, a, b, c, F4, K4,  8,  6, x)
        c, e = R(c, d, e, a, b, F4, K4,  5, 15, x)
        b, d = R(b, c, d, e, a, F4, K4,  6, 13, x) #/* #79 */

        aa = a
        bb = b
        cc = c
        dd = d
        ee = e

        a = state[0]
        b = state[1]
        c = state[2]
        d = state[3]
        e = state[4]

        #/* Parallel round 1 */
        a, c = R(a, b, c, d, e, F4, KK0,  8,  5, x)
        e, b = R(e, a, b, c, d, F4, KK0,  9, 14, x)
        d, a = R(d, e, a, b, c, F4, KK0,  9,  7, x)
        c, e = R(c, d, e, a, b, F4, KK0, 11,  0, x)
        b, d = R(b, c, d, e, a, F4, KK0, 13,  9, x)
        a, c = R(a, b, c, d, e, F4, KK0, 15,  2, x)
        e, b = R(e, a, b, c, d, F4, KK0, 15, 11, x)
        d, a = R(d, e, a, b, c, F4, KK0,  5,  4, x)
        c, e = R(c, d, e, a, b, F4, KK0,  7, 13, x)
        b, d = R(b, c, d, e, a, F4, KK0,  7,  6, x)
        a, c = R(a, b, c, d, e, F4, KK0,  8, 15, x)
        e, b = R(e, a, b, c, d, F4, KK0, 11,  8, x)
        d, a = R(d, e, a, b, c, F4, KK0, 14,  1, x)
        c, e = R(c, d, e, a, b, F4, KK0, 14, 10, x)
        b, d = R(b, c, d, e, a, F4, KK0, 12,  3, x)
        a, c = R(a, b, c, d, e, F4, KK0,  6, 12, x) #/* #15 */
        #/* Parallel round 2 */
        e, b = R(e, a, b, c, d, F3, KK1,  9,  6, x)
        d, a = R(d, e, a, b, c, F3, KK1, 13, 11, x)
        c, e = R(c, d, e, a, b, F3, KK1, 15,  3, x)
        b, d = R(b, c, d, e, a, F3, KK1,  7,  7, x)
        a, c = R(a, b, c, d, e, F3, KK1, 12,  0, x)
        e, b = R(e, a, b, c, d, F3, KK1,  8, 13, x)
        d, a = R(d, e, a, b, c, F3, KK1,  9,  5, x)
        c, e = R(c, d, e, a, b, F3, KK1, 11, 10, x)
        b, d = R(b, c, d, e, a, F3, KK1,  7, 14, x)
        a, c = R(a, b, c, d, e, F3, KK1,  7, 15, x)
        e, b = R(e, a, b, c, d, F3, KK1, 12,  8, x)
        d, a = R(d, e, a, b, c, F3, KK1,  7, 12, x)
        c, e = R(c, d, e, a, b, F3, KK1,  6,  4, x)
        b, d = R(b, c, d, e, a, F3, KK1, 15,  9, x)
        a, c = R(a, b, c, d, e, F3, KK1, 13,  1, x)
        e, b = R(e, a, b, c, d, F3, KK1, 11,  2, x) #/* #31 */
        #/* Parallel round 3 */
        d, a = R(d, e, a, b, c, F2, KK2,  9, 15, x)
        c, e = R(c, d, e, a, b, F2, KK2,  7,  5, x)
        b, d = R(b, c, d, e, a, F2, KK2, 15,  1, x)
        a, c = R(a, b, c, d, e, F2, KK2, 11,  3, x)
        e, b = R(e, a, b, c, d, F2, KK2,  8,  7, x)
        d, a = R(d, e, a, b, c, F2, KK2,  6, 14, x)
        c, e = R(c, d, e, a, b, F2, KK2,  6,  6, x)
        b, d = R(b, c, d, e, a, F2, KK2, 14,  9, x)
        a, c = R(a, b, c, d, e, F2, KK2, 12, 11, x)
        e, b = R(e, a, b, c, d, F2, KK2, 13,  8, x)
        d, a = R(d, e, a, b, c, F2, KK2,  5, 12, x)
        c, e = R(c, d, e, a, b, F2, KK2, 14,  2, x)
        b, d = R(b, c, d, e, a, F2, KK2, 13, 10, x)
        a, c = R(a, b, c, d, e, F2, KK2, 13,  0, x)
        e, b = R(e, a, b, c, d, F2, KK2,  7,  4, x)
        d, a = R(d, e, a, b, c, F2, KK2,  5, 13, x) #/* #47 */
        #/* Parallel round 4 */
        c, e = R(c, d, e, a, b, F1, KK3, 15,  8, x)
        b, d = R(b, c, d, e, a, F1, KK3,  5,  6, x)
        a, c = R(a, b, c, d, e, F1, KK3,  8,  4, x)
        e, b = R(e, a, b, c, d, F1, KK3, 11,  1, x)
        d, a = R(d, e, a, b, c, F1, KK3, 14,  3, x)
        c, e = R(c, d, e, a, b, F1, KK3, 14, 11, x)
        b, d = R(b, c, d, e, a, F1, KK3,  6, 15, x)
        a, c = R(a, b, c, d, e, F1, KK3, 14,  0, x)
        e, b = R(e, a, b, c, d, F1, KK3,  6,  5, x)
        d, a = R(d, e, a, b, c, F1, KK3,  9, 12, x)
        c, e = R(c, d, e, a, b, F1, KK3, 12,  2, x)
        b, d = R(b, c, d, e, a, F1, KK3,  9, 13, x)
        a, c = R(a, b, c, d, e, F1, KK3, 12,  9, x)
        e, b = R(e, a, b, c, d, F1, KK3,  5,  7, x)
        d, a = R(d, e, a, b, c, F1, KK3, 15, 10, x)
        c, e = R(c, d, e, a, b, F1, KK3,  8, 14, x) #/* #63 */
        #/* Parallel round 5 */
        b, d = R(b, c, d, e, a, F0, KK4,  8, 12, x)
        a, c = R(a, b, c, d, e, F0, KK4,  5, 15, x)
        e, b = R(e, a, b, c, d, F0, KK4, 12, 10, x)
        d, a = R(d, e, a, b, c, F0, KK4,  9,  4, x)
        c, e = R(c, d, e, a, b, F0, KK4, 12,  1, x)
        b, d = R(b, c, d, e, a, F0, KK4,  5,  5, x)
        a, c = R(a, b, c, d, e, F0, KK4, 14,  8, x)
        e, b = R(e, a, b, c, d, F0, KK4,  6,  7, x)
        d, a = R(d, e, a, b, c, F0, KK4,  8,  6, x)
        c, e = R(c, d, e, a, b, F0, KK4, 13,  2, x)
        b, d = R(b, c, d, e, a, F0, KK4,  6, 13, x)
        a, c = R(a, b, c, d, e, F0, KK4,  5, 14, x)
        e, b = R(e, a, b, c, d, F0, KK4, 15,  0, x)
        d, a = R(d, e, a, b, c, F0, KK4, 13,  3, x)
        c, e = R(c, d, e, a, b, F0, KK4, 11,  9, x)
        b, d = R(b, c, d, e, a, F0, KK4, 11, 11, x) #/* #79 */

        t = (state[1] + cc + d) % 0x100000000
        state[1] = (state[2] + dd + e) % 0x100000000
        state[2] = (state[3] + ee + a) % 0x100000000
        state[3] = (state[4] + aa + b) % 0x100000000
        state[4] = (state[0] + bb + c) % 0x100000000
        state[0] = t % 0x100000000

    return ripemd160

ripemd160 = gen_ripemd160_with_variable_scope_protector_to_not_pollute_global_namespace()
print(ripemd160(b'hello this is a test').hex())
print("number of bytes in a RIPEMD-160 digest: ", len(ripemd160(b'')))

```

Ok giá» thÃ¬ cÃ³ thá»ƒ lÃ m viá»‡c vá»›i Bitcoin Address. ChÃºng ta sáº½ táº¡o má»™t class `PublicKet`, lÃ  con cá»§a `Point`, cÅ©ng lÃ  má»™t Ä‘iá»ƒm trÃªn `Curve`.

```{python}
class PublicKey(Point):
    """
    The public key is just a Point on a Curve, but has some additional specific
    encoding / decoding functionality that this class implements.
    """

    @classmethod
    def from_point(cls, pt: Point):
        """ promote a Point to be a PublicKey """
        return cls(pt.curve, pt.x, pt.y)

    def encode(self, compressed, hash160=False):
        """ return the SEC bytes encoding of the public key Point """
        # calculate the bytes
        if compressed:
            # (x,y) is very redundant. Because y^2 = x^3 + 7,
            # we can just encode x, and then y = +/- sqrt(x^3 + 7),
            # so we need one more bit to encode whether it was the + or the -
            # but because this is modular arithmetic there is no +/-, instead
            # it can be shown that one y will always be even and the other odd.
            prefix = b'\x02' if self.y % 2 == 0 else b'\x03'
            pkb = prefix + self.x.to_bytes(32, 'big')
        else:
            pkb = b'\x04' + self.x.to_bytes(32, 'big') + self.y.to_bytes(32, 'big')
        # hash if desired
        return ripemd160(sha256(pkb)) if hash160 else pkb

    def address(self, net: str, compressed: bool) -> str:
        """ return the associated bitcoin address for this public key as string """
        # encode the public key into bytes and hash to get the payload
        pkb_hash = self.encode(compressed=compressed, hash160=True)
        # add version byte (0x00 for Main Network, or 0x6f for Test Network)
        version = {'main': b'\x00', 'test': b'\x6f'}
        ver_pkb_hash = version[net] + pkb_hash
        # calculate the checksum
        checksum = sha256(sha256(ver_pkb_hash))[:4]
        # append to form the full 25-byte binary Bitcoin Address
        byte_address = ver_pkb_hash + checksum
        # finally b58 encode the result
        b58check_address = b58encode(byte_address)
        return b58check_address
```

Step 1 not completed yet.

## Part 1: summary so far

# Part 2: Obtaining seed funds + intro to Bitcoin under the hood

# Part 3: Crafting our transaction

# Digital Signature

# Putting it all together: One more consolidating transaction

# Resources

Andrej Karpathy's [blog post](https://karpathy.github.io/2021/06/21/blockchain/)